module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateBadge {
  count: Int!
}

type AggregateBan {
  count: Int!
}

type AggregateBot {
  count: Int!
}

type AggregateCatalogFeatured {
  count: Int!
}

type AggregateCatalogItems {
  count: Int!
}

type AggregateCatalogPage {
  count: Int!
}

type AggregateChatlog {
  count: Int!
}

type AggregateChatlogConsole {
  count: Int!
}

type AggregateChatlogConsoleInvitations {
  count: Int!
}

type AggregateCurrencies {
  count: Int!
}

type AggregateHabbo {
  count: Int!
}

type AggregateLanguage {
  count: Int!
}

type AggregateNavigatorCategory {
  count: Int!
}

type AggregateNavigatorTab {
  count: Int!
}

type AggregateNews {
  count: Int!
}

type AggregateRank {
  count: Int!
}

type AggregateRoom {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type Badge {
  id: ID!
  code: String!
  description: String
}

type BadgeConnection {
  pageInfo: PageInfo!
  edges: [BadgeEdge]!
  aggregate: AggregateBadge!
}

input BadgeCreateInput {
  id: ID
  code: String!
  description: String
}

type BadgeEdge {
  node: Badge!
  cursor: String!
}

enum BadgeOrderByInput {
  id_ASC
  id_DESC
  code_ASC
  code_DESC
  description_ASC
  description_DESC
}

type BadgePreviousValues {
  id: ID!
  code: String!
  description: String
}

type BadgeSubscriptionPayload {
  mutation: MutationType!
  node: Badge
  updatedFields: [String!]
  previousValues: BadgePreviousValues
}

input BadgeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BadgeWhereInput
  AND: [BadgeSubscriptionWhereInput!]
  OR: [BadgeSubscriptionWhereInput!]
  NOT: [BadgeSubscriptionWhereInput!]
}

input BadgeUpdateInput {
  code: String
  description: String
}

input BadgeUpdateManyMutationInput {
  code: String
  description: String
}

input BadgeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [BadgeWhereInput!]
  OR: [BadgeWhereInput!]
  NOT: [BadgeWhereInput!]
}

input BadgeWhereUniqueInput {
  id: ID
  code: String
}

type Ban {
  id: ID!
  reason: String
  status: banStatus
  type: banType
  user: Int
  ip: String
  machine: String
  by: Int
  createdAt: DateTime
  updatedAt: DateTime
}

type BanConnection {
  pageInfo: PageInfo!
  edges: [BanEdge]!
  aggregate: AggregateBan!
}

input BanCreateInput {
  id: ID
  reason: String
  status: banStatus
  type: banType
  user: Int
  ip: String
  machine: String
  by: Int
}

type BanEdge {
  node: Ban!
  cursor: String!
}

enum BanOrderByInput {
  id_ASC
  id_DESC
  reason_ASC
  reason_DESC
  status_ASC
  status_DESC
  type_ASC
  type_DESC
  user_ASC
  user_DESC
  ip_ASC
  ip_DESC
  machine_ASC
  machine_DESC
  by_ASC
  by_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BanPreviousValues {
  id: ID!
  reason: String
  status: banStatus
  type: banType
  user: Int
  ip: String
  machine: String
  by: Int
  createdAt: DateTime
  updatedAt: DateTime
}

enum banStatus {
  BANNED
  APPEALING
  REJECTED
}

type BanSubscriptionPayload {
  mutation: MutationType!
  node: Ban
  updatedFields: [String!]
  previousValues: BanPreviousValues
}

input BanSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BanWhereInput
  AND: [BanSubscriptionWhereInput!]
  OR: [BanSubscriptionWhereInput!]
  NOT: [BanSubscriptionWhereInput!]
}

enum banType {
  USER
  IP
  MACHINE
}

input BanUpdateInput {
  reason: String
  status: banStatus
  type: banType
  user: Int
  ip: String
  machine: String
  by: Int
}

input BanUpdateManyMutationInput {
  reason: String
  status: banStatus
  type: banType
  user: Int
  ip: String
  machine: String
  by: Int
}

input BanWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  reason: String
  reason_not: String
  reason_in: [String!]
  reason_not_in: [String!]
  reason_lt: String
  reason_lte: String
  reason_gt: String
  reason_gte: String
  reason_contains: String
  reason_not_contains: String
  reason_starts_with: String
  reason_not_starts_with: String
  reason_ends_with: String
  reason_not_ends_with: String
  status: banStatus
  status_not: banStatus
  status_in: [banStatus!]
  status_not_in: [banStatus!]
  type: banType
  type_not: banType
  type_in: [banType!]
  type_not_in: [banType!]
  user: Int
  user_not: Int
  user_in: [Int!]
  user_not_in: [Int!]
  user_lt: Int
  user_lte: Int
  user_gt: Int
  user_gte: Int
  ip: String
  ip_not: String
  ip_in: [String!]
  ip_not_in: [String!]
  ip_lt: String
  ip_lte: String
  ip_gt: String
  ip_gte: String
  ip_contains: String
  ip_not_contains: String
  ip_starts_with: String
  ip_not_starts_with: String
  ip_ends_with: String
  ip_not_ends_with: String
  machine: String
  machine_not: String
  machine_in: [String!]
  machine_not_in: [String!]
  machine_lt: String
  machine_lte: String
  machine_gt: String
  machine_gte: String
  machine_contains: String
  machine_not_contains: String
  machine_starts_with: String
  machine_not_starts_with: String
  machine_ends_with: String
  machine_not_ends_with: String
  by: Int
  by_not: Int
  by_in: [Int!]
  by_not_in: [Int!]
  by_lt: Int
  by_lte: Int
  by_gt: Int
  by_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [BanWhereInput!]
  OR: [BanWhereInput!]
  NOT: [BanWhereInput!]
}

input BanWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Bot {
  id: ID!
  name: String
  motto: String
  inventory: Boolean
  owner: Int
  gender: Boolean
  figure: String
  type: String
  state: [String!]!
  action: [String!]!
  position: [Int!]!
  messages: String
  chatBubble: Int
  chatAuto: Int
  chatRandom: Boolean
  chatDelay: Int
}

type BotConnection {
  pageInfo: PageInfo!
  edges: [BotEdge]!
  aggregate: AggregateBot!
}

input BotCreateactionInput {
  set: [String!]
}

input BotCreateInput {
  id: ID
  name: String
  motto: String
  inventory: Boolean
  owner: Int
  gender: Boolean
  figure: String
  type: String
  state: BotCreatestateInput
  action: BotCreateactionInput
  position: BotCreatepositionInput
  messages: String
  chatBubble: Int
  chatAuto: Int
  chatRandom: Boolean
  chatDelay: Int
}

input BotCreatepositionInput {
  set: [Int!]
}

input BotCreatestateInput {
  set: [String!]
}

type BotEdge {
  node: Bot!
  cursor: String!
}

enum BotOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  motto_ASC
  motto_DESC
  inventory_ASC
  inventory_DESC
  owner_ASC
  owner_DESC
  gender_ASC
  gender_DESC
  figure_ASC
  figure_DESC
  type_ASC
  type_DESC
  messages_ASC
  messages_DESC
  chatBubble_ASC
  chatBubble_DESC
  chatAuto_ASC
  chatAuto_DESC
  chatRandom_ASC
  chatRandom_DESC
  chatDelay_ASC
  chatDelay_DESC
}

type BotPreviousValues {
  id: ID!
  name: String
  motto: String
  inventory: Boolean
  owner: Int
  gender: Boolean
  figure: String
  type: String
  state: [String!]!
  action: [String!]!
  position: [Int!]!
  messages: String
  chatBubble: Int
  chatAuto: Int
  chatRandom: Boolean
  chatDelay: Int
}

type BotSubscriptionPayload {
  mutation: MutationType!
  node: Bot
  updatedFields: [String!]
  previousValues: BotPreviousValues
}

input BotSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BotWhereInput
  AND: [BotSubscriptionWhereInput!]
  OR: [BotSubscriptionWhereInput!]
  NOT: [BotSubscriptionWhereInput!]
}

input BotUpdateactionInput {
  set: [String!]
}

input BotUpdateInput {
  name: String
  motto: String
  inventory: Boolean
  owner: Int
  gender: Boolean
  figure: String
  type: String
  state: BotUpdatestateInput
  action: BotUpdateactionInput
  position: BotUpdatepositionInput
  messages: String
  chatBubble: Int
  chatAuto: Int
  chatRandom: Boolean
  chatDelay: Int
}

input BotUpdateManyMutationInput {
  name: String
  motto: String
  inventory: Boolean
  owner: Int
  gender: Boolean
  figure: String
  type: String
  state: BotUpdatestateInput
  action: BotUpdateactionInput
  position: BotUpdatepositionInput
  messages: String
  chatBubble: Int
  chatAuto: Int
  chatRandom: Boolean
  chatDelay: Int
}

input BotUpdatepositionInput {
  set: [Int!]
}

input BotUpdatestateInput {
  set: [String!]
}

input BotWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  motto: String
  motto_not: String
  motto_in: [String!]
  motto_not_in: [String!]
  motto_lt: String
  motto_lte: String
  motto_gt: String
  motto_gte: String
  motto_contains: String
  motto_not_contains: String
  motto_starts_with: String
  motto_not_starts_with: String
  motto_ends_with: String
  motto_not_ends_with: String
  inventory: Boolean
  inventory_not: Boolean
  owner: Int
  owner_not: Int
  owner_in: [Int!]
  owner_not_in: [Int!]
  owner_lt: Int
  owner_lte: Int
  owner_gt: Int
  owner_gte: Int
  gender: Boolean
  gender_not: Boolean
  figure: String
  figure_not: String
  figure_in: [String!]
  figure_not_in: [String!]
  figure_lt: String
  figure_lte: String
  figure_gt: String
  figure_gte: String
  figure_contains: String
  figure_not_contains: String
  figure_starts_with: String
  figure_not_starts_with: String
  figure_ends_with: String
  figure_not_ends_with: String
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  messages: String
  messages_not: String
  messages_in: [String!]
  messages_not_in: [String!]
  messages_lt: String
  messages_lte: String
  messages_gt: String
  messages_gte: String
  messages_contains: String
  messages_not_contains: String
  messages_starts_with: String
  messages_not_starts_with: String
  messages_ends_with: String
  messages_not_ends_with: String
  chatBubble: Int
  chatBubble_not: Int
  chatBubble_in: [Int!]
  chatBubble_not_in: [Int!]
  chatBubble_lt: Int
  chatBubble_lte: Int
  chatBubble_gt: Int
  chatBubble_gte: Int
  chatAuto: Int
  chatAuto_not: Int
  chatAuto_in: [Int!]
  chatAuto_not_in: [Int!]
  chatAuto_lt: Int
  chatAuto_lte: Int
  chatAuto_gt: Int
  chatAuto_gte: Int
  chatRandom: Boolean
  chatRandom_not: Boolean
  chatDelay: Int
  chatDelay_not: Int
  chatDelay_in: [Int!]
  chatDelay_not_in: [Int!]
  chatDelay_lt: Int
  chatDelay_lte: Int
  chatDelay_gt: Int
  chatDelay_gte: Int
  AND: [BotWhereInput!]
  OR: [BotWhereInput!]
  NOT: [BotWhereInput!]
}

input BotWhereUniqueInput {
  id: ID
}

type CatalogFeatured {
  id: ID!
  caption: String
  image: String
  link: CatalogPage
  slot: Int
  updated: DateTime
}

type CatalogFeaturedConnection {
  pageInfo: PageInfo!
  edges: [CatalogFeaturedEdge]!
  aggregate: AggregateCatalogFeatured!
}

input CatalogFeaturedCreateInput {
  id: ID
  caption: String
  image: String
  link: CatalogPageCreateOneInput
  slot: Int
}

type CatalogFeaturedEdge {
  node: CatalogFeatured!
  cursor: String!
}

enum CatalogFeaturedOrderByInput {
  id_ASC
  id_DESC
  caption_ASC
  caption_DESC
  image_ASC
  image_DESC
  slot_ASC
  slot_DESC
  updated_ASC
  updated_DESC
}

type CatalogFeaturedPreviousValues {
  id: ID!
  caption: String
  image: String
  slot: Int
  updated: DateTime
}

type CatalogFeaturedSubscriptionPayload {
  mutation: MutationType!
  node: CatalogFeatured
  updatedFields: [String!]
  previousValues: CatalogFeaturedPreviousValues
}

input CatalogFeaturedSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CatalogFeaturedWhereInput
  AND: [CatalogFeaturedSubscriptionWhereInput!]
  OR: [CatalogFeaturedSubscriptionWhereInput!]
  NOT: [CatalogFeaturedSubscriptionWhereInput!]
}

input CatalogFeaturedUpdateInput {
  caption: String
  image: String
  link: CatalogPageUpdateOneInput
  slot: Int
}

input CatalogFeaturedUpdateManyMutationInput {
  caption: String
  image: String
  slot: Int
}

input CatalogFeaturedWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  caption: String
  caption_not: String
  caption_in: [String!]
  caption_not_in: [String!]
  caption_lt: String
  caption_lte: String
  caption_gt: String
  caption_gte: String
  caption_contains: String
  caption_not_contains: String
  caption_starts_with: String
  caption_not_starts_with: String
  caption_ends_with: String
  caption_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  link: CatalogPageWhereInput
  slot: Int
  slot_not: Int
  slot_in: [Int!]
  slot_not_in: [Int!]
  slot_lt: Int
  slot_lte: Int
  slot_gt: Int
  slot_gte: Int
  updated: DateTime
  updated_not: DateTime
  updated_in: [DateTime!]
  updated_not_in: [DateTime!]
  updated_lt: DateTime
  updated_lte: DateTime
  updated_gt: DateTime
  updated_gte: DateTime
  AND: [CatalogFeaturedWhereInput!]
  OR: [CatalogFeaturedWhereInput!]
  NOT: [CatalogFeaturedWhereInput!]
}

input CatalogFeaturedWhereUniqueInput {
  id: ID
}

type CatalogItems {
  id: ID!
  page: CatalogPage
  name: String!
  amount: Int
  club: Boolean
  available: Int
  limit: Int
  discount: Boolean
}

type CatalogItemsConnection {
  pageInfo: PageInfo!
  edges: [CatalogItemsEdge]!
  aggregate: AggregateCatalogItems!
}

input CatalogItemsCreateInput {
  id: ID
  page: CatalogPageCreateOneInput
  name: String!
  amount: Int
  club: Boolean
  available: Int
  limit: Int
  discount: Boolean
}

type CatalogItemsEdge {
  node: CatalogItems!
  cursor: String!
}

enum CatalogItemsOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  amount_ASC
  amount_DESC
  club_ASC
  club_DESC
  available_ASC
  available_DESC
  limit_ASC
  limit_DESC
  discount_ASC
  discount_DESC
}

type CatalogItemsPreviousValues {
  id: ID!
  name: String!
  amount: Int
  club: Boolean
  available: Int
  limit: Int
  discount: Boolean
}

type CatalogItemsSubscriptionPayload {
  mutation: MutationType!
  node: CatalogItems
  updatedFields: [String!]
  previousValues: CatalogItemsPreviousValues
}

input CatalogItemsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CatalogItemsWhereInput
  AND: [CatalogItemsSubscriptionWhereInput!]
  OR: [CatalogItemsSubscriptionWhereInput!]
  NOT: [CatalogItemsSubscriptionWhereInput!]
}

input CatalogItemsUpdateInput {
  page: CatalogPageUpdateOneInput
  name: String
  amount: Int
  club: Boolean
  available: Int
  limit: Int
  discount: Boolean
}

input CatalogItemsUpdateManyMutationInput {
  name: String
  amount: Int
  club: Boolean
  available: Int
  limit: Int
  discount: Boolean
}

input CatalogItemsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  page: CatalogPageWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  club: Boolean
  club_not: Boolean
  available: Int
  available_not: Int
  available_in: [Int!]
  available_not_in: [Int!]
  available_lt: Int
  available_lte: Int
  available_gt: Int
  available_gte: Int
  limit: Int
  limit_not: Int
  limit_in: [Int!]
  limit_not_in: [Int!]
  limit_lt: Int
  limit_lte: Int
  limit_gt: Int
  limit_gte: Int
  discount: Boolean
  discount_not: Boolean
  AND: [CatalogItemsWhereInput!]
  OR: [CatalogItemsWhereInput!]
  NOT: [CatalogItemsWhereInput!]
}

input CatalogItemsWhereUniqueInput {
  id: ID
}

type CatalogPage {
  id: ID!
  link: String!
  parent: CatalogPage
  layout: CatalogPageLayout
  order: Int
  name: String
  language: Language
  description: String
  icon: String
  banner: String
  teaser: String
  visible: Boolean
  enabled: Boolean
  rank: Int
  club: Boolean
  vip: Boolean
  body: Json
  product: Json
}

type CatalogPageConnection {
  pageInfo: PageInfo!
  edges: [CatalogPageEdge]!
  aggregate: AggregateCatalogPage!
}

input CatalogPageCreateInput {
  id: ID
  link: String!
  parent: CatalogPageCreateOneInput
  layout: CatalogPageLayout
  order: Int
  name: String
  language: LanguageCreateOneInput
  description: String
  icon: String
  banner: String
  teaser: String
  visible: Boolean
  enabled: Boolean
  rank: Int
  club: Boolean
  vip: Boolean
  body: Json
  product: Json
}

input CatalogPageCreateOneInput {
  create: CatalogPageCreateInput
  connect: CatalogPageWhereUniqueInput
}

type CatalogPageEdge {
  node: CatalogPage!
  cursor: String!
}

enum CatalogPageLayout {
  DEFAULT
  FRONTPAGE
  CLUB_BUY
  CLUB_GIFT
  RECYCLER
  RECYCLER_INFO
  RECYCLER_PRIZES
  TROPHIES
  PLASTO
  MARKETPLACE
  MARKETPLACE_OWN_ITEMS
  PETS
  SPACES
  SOUNDMACHINE
  GUILDS
  INFO_DUCKETS
  INFO_RENTABLES
  INFO_PETS
  ROOMADS
  SINGLE_BUNDLE
  SOLD_LTD_ITEMS
  BADGE_DISPLAY
  BOTS
}

enum CatalogPageOrderByInput {
  id_ASC
  id_DESC
  link_ASC
  link_DESC
  layout_ASC
  layout_DESC
  order_ASC
  order_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  icon_ASC
  icon_DESC
  banner_ASC
  banner_DESC
  teaser_ASC
  teaser_DESC
  visible_ASC
  visible_DESC
  enabled_ASC
  enabled_DESC
  rank_ASC
  rank_DESC
  club_ASC
  club_DESC
  vip_ASC
  vip_DESC
  body_ASC
  body_DESC
  product_ASC
  product_DESC
}

type CatalogPagePreviousValues {
  id: ID!
  link: String!
  layout: CatalogPageLayout
  order: Int
  name: String
  description: String
  icon: String
  banner: String
  teaser: String
  visible: Boolean
  enabled: Boolean
  rank: Int
  club: Boolean
  vip: Boolean
  body: Json
  product: Json
}

type CatalogPageSubscriptionPayload {
  mutation: MutationType!
  node: CatalogPage
  updatedFields: [String!]
  previousValues: CatalogPagePreviousValues
}

input CatalogPageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CatalogPageWhereInput
  AND: [CatalogPageSubscriptionWhereInput!]
  OR: [CatalogPageSubscriptionWhereInput!]
  NOT: [CatalogPageSubscriptionWhereInput!]
}

input CatalogPageUpdateDataInput {
  link: String
  parent: CatalogPageUpdateOneInput
  layout: CatalogPageLayout
  order: Int
  name: String
  language: LanguageUpdateOneInput
  description: String
  icon: String
  banner: String
  teaser: String
  visible: Boolean
  enabled: Boolean
  rank: Int
  club: Boolean
  vip: Boolean
  body: Json
  product: Json
}

input CatalogPageUpdateInput {
  link: String
  parent: CatalogPageUpdateOneInput
  layout: CatalogPageLayout
  order: Int
  name: String
  language: LanguageUpdateOneInput
  description: String
  icon: String
  banner: String
  teaser: String
  visible: Boolean
  enabled: Boolean
  rank: Int
  club: Boolean
  vip: Boolean
  body: Json
  product: Json
}

input CatalogPageUpdateManyMutationInput {
  link: String
  layout: CatalogPageLayout
  order: Int
  name: String
  description: String
  icon: String
  banner: String
  teaser: String
  visible: Boolean
  enabled: Boolean
  rank: Int
  club: Boolean
  vip: Boolean
  body: Json
  product: Json
}

input CatalogPageUpdateOneInput {
  create: CatalogPageCreateInput
  update: CatalogPageUpdateDataInput
  upsert: CatalogPageUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CatalogPageWhereUniqueInput
}

input CatalogPageUpsertNestedInput {
  update: CatalogPageUpdateDataInput!
  create: CatalogPageCreateInput!
}

input CatalogPageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  parent: CatalogPageWhereInput
  layout: CatalogPageLayout
  layout_not: CatalogPageLayout
  layout_in: [CatalogPageLayout!]
  layout_not_in: [CatalogPageLayout!]
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  language: LanguageWhereInput
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  icon: String
  icon_not: String
  icon_in: [String!]
  icon_not_in: [String!]
  icon_lt: String
  icon_lte: String
  icon_gt: String
  icon_gte: String
  icon_contains: String
  icon_not_contains: String
  icon_starts_with: String
  icon_not_starts_with: String
  icon_ends_with: String
  icon_not_ends_with: String
  banner: String
  banner_not: String
  banner_in: [String!]
  banner_not_in: [String!]
  banner_lt: String
  banner_lte: String
  banner_gt: String
  banner_gte: String
  banner_contains: String
  banner_not_contains: String
  banner_starts_with: String
  banner_not_starts_with: String
  banner_ends_with: String
  banner_not_ends_with: String
  teaser: String
  teaser_not: String
  teaser_in: [String!]
  teaser_not_in: [String!]
  teaser_lt: String
  teaser_lte: String
  teaser_gt: String
  teaser_gte: String
  teaser_contains: String
  teaser_not_contains: String
  teaser_starts_with: String
  teaser_not_starts_with: String
  teaser_ends_with: String
  teaser_not_ends_with: String
  visible: Boolean
  visible_not: Boolean
  enabled: Boolean
  enabled_not: Boolean
  rank: Int
  rank_not: Int
  rank_in: [Int!]
  rank_not_in: [Int!]
  rank_lt: Int
  rank_lte: Int
  rank_gt: Int
  rank_gte: Int
  club: Boolean
  club_not: Boolean
  vip: Boolean
  vip_not: Boolean
  AND: [CatalogPageWhereInput!]
  OR: [CatalogPageWhereInput!]
  NOT: [CatalogPageWhereInput!]
}

input CatalogPageWhereUniqueInput {
  id: ID
  link: String
}

type Chatlog {
  id: ID!
  habbo: Habbo!
  room: Room!
  message: String
  createdAt: DateTime
}

type ChatlogConnection {
  pageInfo: PageInfo!
  edges: [ChatlogEdge]!
  aggregate: AggregateChatlog!
}

type ChatlogConsole {
  id: ID!
  from: Habbo!
  to: Habbo!
  message: String
  createdAt: DateTime
}

type ChatlogConsoleConnection {
  pageInfo: PageInfo!
  edges: [ChatlogConsoleEdge]!
  aggregate: AggregateChatlogConsole!
}

input ChatlogConsoleCreateInput {
  id: ID
  from: HabboCreateOneInput!
  to: HabboCreateOneInput!
  message: String
}

type ChatlogConsoleEdge {
  node: ChatlogConsole!
  cursor: String!
}

type ChatlogConsoleInvitations {
  id: ID!
  from: Habbo!
  to: Habbo!
  message: String
  room: Room!
  createdAt: DateTime
}

type ChatlogConsoleInvitationsConnection {
  pageInfo: PageInfo!
  edges: [ChatlogConsoleInvitationsEdge]!
  aggregate: AggregateChatlogConsoleInvitations!
}

input ChatlogConsoleInvitationsCreateInput {
  id: ID
  from: HabboCreateOneInput!
  to: HabboCreateOneInput!
  message: String
  room: RoomCreateOneInput!
}

type ChatlogConsoleInvitationsEdge {
  node: ChatlogConsoleInvitations!
  cursor: String!
}

enum ChatlogConsoleInvitationsOrderByInput {
  id_ASC
  id_DESC
  message_ASC
  message_DESC
  createdAt_ASC
  createdAt_DESC
}

type ChatlogConsoleInvitationsPreviousValues {
  id: ID!
  message: String
  createdAt: DateTime
}

type ChatlogConsoleInvitationsSubscriptionPayload {
  mutation: MutationType!
  node: ChatlogConsoleInvitations
  updatedFields: [String!]
  previousValues: ChatlogConsoleInvitationsPreviousValues
}

input ChatlogConsoleInvitationsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ChatlogConsoleInvitationsWhereInput
  AND: [ChatlogConsoleInvitationsSubscriptionWhereInput!]
  OR: [ChatlogConsoleInvitationsSubscriptionWhereInput!]
  NOT: [ChatlogConsoleInvitationsSubscriptionWhereInput!]
}

input ChatlogConsoleInvitationsUpdateInput {
  from: HabboUpdateOneRequiredInput
  to: HabboUpdateOneRequiredInput
  message: String
  room: RoomUpdateOneRequiredInput
}

input ChatlogConsoleInvitationsUpdateManyMutationInput {
  message: String
}

input ChatlogConsoleInvitationsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  from: HabboWhereInput
  to: HabboWhereInput
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  room: RoomWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ChatlogConsoleInvitationsWhereInput!]
  OR: [ChatlogConsoleInvitationsWhereInput!]
  NOT: [ChatlogConsoleInvitationsWhereInput!]
}

input ChatlogConsoleInvitationsWhereUniqueInput {
  id: ID
}

enum ChatlogConsoleOrderByInput {
  id_ASC
  id_DESC
  message_ASC
  message_DESC
  createdAt_ASC
  createdAt_DESC
}

type ChatlogConsolePreviousValues {
  id: ID!
  message: String
  createdAt: DateTime
}

type ChatlogConsoleSubscriptionPayload {
  mutation: MutationType!
  node: ChatlogConsole
  updatedFields: [String!]
  previousValues: ChatlogConsolePreviousValues
}

input ChatlogConsoleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ChatlogConsoleWhereInput
  AND: [ChatlogConsoleSubscriptionWhereInput!]
  OR: [ChatlogConsoleSubscriptionWhereInput!]
  NOT: [ChatlogConsoleSubscriptionWhereInput!]
}

input ChatlogConsoleUpdateInput {
  from: HabboUpdateOneRequiredInput
  to: HabboUpdateOneRequiredInput
  message: String
}

input ChatlogConsoleUpdateManyMutationInput {
  message: String
}

input ChatlogConsoleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  from: HabboWhereInput
  to: HabboWhereInput
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ChatlogConsoleWhereInput!]
  OR: [ChatlogConsoleWhereInput!]
  NOT: [ChatlogConsoleWhereInput!]
}

input ChatlogConsoleWhereUniqueInput {
  id: ID
}

input ChatlogCreateInput {
  id: ID
  habbo: HabboCreateOneInput!
  room: RoomCreateOneInput!
  message: String
}

type ChatlogEdge {
  node: Chatlog!
  cursor: String!
}

enum ChatlogOrderByInput {
  id_ASC
  id_DESC
  message_ASC
  message_DESC
  createdAt_ASC
  createdAt_DESC
}

type ChatlogPreviousValues {
  id: ID!
  message: String
  createdAt: DateTime
}

type ChatlogSubscriptionPayload {
  mutation: MutationType!
  node: Chatlog
  updatedFields: [String!]
  previousValues: ChatlogPreviousValues
}

input ChatlogSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ChatlogWhereInput
  AND: [ChatlogSubscriptionWhereInput!]
  OR: [ChatlogSubscriptionWhereInput!]
  NOT: [ChatlogSubscriptionWhereInput!]
}

input ChatlogUpdateInput {
  habbo: HabboUpdateOneRequiredInput
  room: RoomUpdateOneRequiredInput
  message: String
}

input ChatlogUpdateManyMutationInput {
  message: String
}

input ChatlogWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  habbo: HabboWhereInput
  room: RoomWhereInput
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ChatlogWhereInput!]
  OR: [ChatlogWhereInput!]
  NOT: [ChatlogWhereInput!]
}

input ChatlogWhereUniqueInput {
  id: ID
}

type Currencies {
  id: ID!
  name: String!
  default: Int
}

type CurrenciesConnection {
  pageInfo: PageInfo!
  edges: [CurrenciesEdge]!
  aggregate: AggregateCurrencies!
}

input CurrenciesCreateInput {
  id: ID
  name: String!
  default: Int
}

type CurrenciesEdge {
  node: Currencies!
  cursor: String!
}

enum CurrenciesOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  default_ASC
  default_DESC
}

type CurrenciesPreviousValues {
  id: ID!
  name: String!
  default: Int
}

type CurrenciesSubscriptionPayload {
  mutation: MutationType!
  node: Currencies
  updatedFields: [String!]
  previousValues: CurrenciesPreviousValues
}

input CurrenciesSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CurrenciesWhereInput
  AND: [CurrenciesSubscriptionWhereInput!]
  OR: [CurrenciesSubscriptionWhereInput!]
  NOT: [CurrenciesSubscriptionWhereInput!]
}

input CurrenciesUpdateInput {
  name: String
  default: Int
}

input CurrenciesUpdateManyMutationInput {
  name: String
  default: Int
}

input CurrenciesWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  default: Int
  default_not: Int
  default_in: [Int!]
  default_not_in: [Int!]
  default_lt: Int
  default_lte: Int
  default_gt: Int
  default_gte: Int
  AND: [CurrenciesWhereInput!]
  OR: [CurrenciesWhereInput!]
  NOT: [CurrenciesWhereInput!]
}

input CurrenciesWhereUniqueInput {
  id: ID
}

scalar DateTime

enum Gender {
  M
  F
}

type Habbo {
  id: ID!
  user: User!
  username: String!
  motto: String
  gender: Gender
  figure: String
  rank: Int
  vip: Int
  online: Boolean
  verified: Int
  home: Int
  volume: Int
  appearOffline: Boolean
  allowTrade: Boolean
  allowGifts: Boolean
  allowMimic: Boolean
  allowFollow: Boolean
  allowWhisper: Boolean
  allowFriendRequests: Boolean
  allowBotSpeech: Boolean
  allowPetSpeech: Boolean
  createdAt: DateTime
  updatedAt: DateTime
}

type HabboConnection {
  pageInfo: PageInfo!
  edges: [HabboEdge]!
  aggregate: AggregateHabbo!
}

input HabboCreateInput {
  id: ID
  user: UserCreateOneWithoutHabbosInput!
  username: String!
  motto: String
  gender: Gender
  figure: String
  rank: Int
  vip: Int
  online: Boolean
  verified: Int
  home: Int
  volume: Int
  appearOffline: Boolean
  allowTrade: Boolean
  allowGifts: Boolean
  allowMimic: Boolean
  allowFollow: Boolean
  allowWhisper: Boolean
  allowFriendRequests: Boolean
  allowBotSpeech: Boolean
  allowPetSpeech: Boolean
}

input HabboCreateManyWithoutUserInput {
  create: [HabboCreateWithoutUserInput!]
  connect: [HabboWhereUniqueInput!]
}

input HabboCreateOneInput {
  create: HabboCreateInput
  connect: HabboWhereUniqueInput
}

input HabboCreateWithoutUserInput {
  id: ID
  username: String!
  motto: String
  gender: Gender
  figure: String
  rank: Int
  vip: Int
  online: Boolean
  verified: Int
  home: Int
  volume: Int
  appearOffline: Boolean
  allowTrade: Boolean
  allowGifts: Boolean
  allowMimic: Boolean
  allowFollow: Boolean
  allowWhisper: Boolean
  allowFriendRequests: Boolean
  allowBotSpeech: Boolean
  allowPetSpeech: Boolean
}

type HabboEdge {
  node: Habbo!
  cursor: String!
}

enum HabboOrderByInput {
  id_ASC
  id_DESC
  username_ASC
  username_DESC
  motto_ASC
  motto_DESC
  gender_ASC
  gender_DESC
  figure_ASC
  figure_DESC
  rank_ASC
  rank_DESC
  vip_ASC
  vip_DESC
  online_ASC
  online_DESC
  verified_ASC
  verified_DESC
  home_ASC
  home_DESC
  volume_ASC
  volume_DESC
  appearOffline_ASC
  appearOffline_DESC
  allowTrade_ASC
  allowTrade_DESC
  allowGifts_ASC
  allowGifts_DESC
  allowMimic_ASC
  allowMimic_DESC
  allowFollow_ASC
  allowFollow_DESC
  allowWhisper_ASC
  allowWhisper_DESC
  allowFriendRequests_ASC
  allowFriendRequests_DESC
  allowBotSpeech_ASC
  allowBotSpeech_DESC
  allowPetSpeech_ASC
  allowPetSpeech_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type HabboPreviousValues {
  id: ID!
  username: String!
  motto: String
  gender: Gender
  figure: String
  rank: Int
  vip: Int
  online: Boolean
  verified: Int
  home: Int
  volume: Int
  appearOffline: Boolean
  allowTrade: Boolean
  allowGifts: Boolean
  allowMimic: Boolean
  allowFollow: Boolean
  allowWhisper: Boolean
  allowFriendRequests: Boolean
  allowBotSpeech: Boolean
  allowPetSpeech: Boolean
  createdAt: DateTime
  updatedAt: DateTime
}

input HabboScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  motto: String
  motto_not: String
  motto_in: [String!]
  motto_not_in: [String!]
  motto_lt: String
  motto_lte: String
  motto_gt: String
  motto_gte: String
  motto_contains: String
  motto_not_contains: String
  motto_starts_with: String
  motto_not_starts_with: String
  motto_ends_with: String
  motto_not_ends_with: String
  gender: Gender
  gender_not: Gender
  gender_in: [Gender!]
  gender_not_in: [Gender!]
  figure: String
  figure_not: String
  figure_in: [String!]
  figure_not_in: [String!]
  figure_lt: String
  figure_lte: String
  figure_gt: String
  figure_gte: String
  figure_contains: String
  figure_not_contains: String
  figure_starts_with: String
  figure_not_starts_with: String
  figure_ends_with: String
  figure_not_ends_with: String
  rank: Int
  rank_not: Int
  rank_in: [Int!]
  rank_not_in: [Int!]
  rank_lt: Int
  rank_lte: Int
  rank_gt: Int
  rank_gte: Int
  vip: Int
  vip_not: Int
  vip_in: [Int!]
  vip_not_in: [Int!]
  vip_lt: Int
  vip_lte: Int
  vip_gt: Int
  vip_gte: Int
  online: Boolean
  online_not: Boolean
  verified: Int
  verified_not: Int
  verified_in: [Int!]
  verified_not_in: [Int!]
  verified_lt: Int
  verified_lte: Int
  verified_gt: Int
  verified_gte: Int
  home: Int
  home_not: Int
  home_in: [Int!]
  home_not_in: [Int!]
  home_lt: Int
  home_lte: Int
  home_gt: Int
  home_gte: Int
  volume: Int
  volume_not: Int
  volume_in: [Int!]
  volume_not_in: [Int!]
  volume_lt: Int
  volume_lte: Int
  volume_gt: Int
  volume_gte: Int
  appearOffline: Boolean
  appearOffline_not: Boolean
  allowTrade: Boolean
  allowTrade_not: Boolean
  allowGifts: Boolean
  allowGifts_not: Boolean
  allowMimic: Boolean
  allowMimic_not: Boolean
  allowFollow: Boolean
  allowFollow_not: Boolean
  allowWhisper: Boolean
  allowWhisper_not: Boolean
  allowFriendRequests: Boolean
  allowFriendRequests_not: Boolean
  allowBotSpeech: Boolean
  allowBotSpeech_not: Boolean
  allowPetSpeech: Boolean
  allowPetSpeech_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [HabboScalarWhereInput!]
  OR: [HabboScalarWhereInput!]
  NOT: [HabboScalarWhereInput!]
}

type HabboSubscriptionPayload {
  mutation: MutationType!
  node: Habbo
  updatedFields: [String!]
  previousValues: HabboPreviousValues
}

input HabboSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HabboWhereInput
  AND: [HabboSubscriptionWhereInput!]
  OR: [HabboSubscriptionWhereInput!]
  NOT: [HabboSubscriptionWhereInput!]
}

input HabboUpdateDataInput {
  user: UserUpdateOneRequiredWithoutHabbosInput
  username: String
  motto: String
  gender: Gender
  figure: String
  rank: Int
  vip: Int
  online: Boolean
  verified: Int
  home: Int
  volume: Int
  appearOffline: Boolean
  allowTrade: Boolean
  allowGifts: Boolean
  allowMimic: Boolean
  allowFollow: Boolean
  allowWhisper: Boolean
  allowFriendRequests: Boolean
  allowBotSpeech: Boolean
  allowPetSpeech: Boolean
}

input HabboUpdateInput {
  user: UserUpdateOneRequiredWithoutHabbosInput
  username: String
  motto: String
  gender: Gender
  figure: String
  rank: Int
  vip: Int
  online: Boolean
  verified: Int
  home: Int
  volume: Int
  appearOffline: Boolean
  allowTrade: Boolean
  allowGifts: Boolean
  allowMimic: Boolean
  allowFollow: Boolean
  allowWhisper: Boolean
  allowFriendRequests: Boolean
  allowBotSpeech: Boolean
  allowPetSpeech: Boolean
}

input HabboUpdateManyDataInput {
  username: String
  motto: String
  gender: Gender
  figure: String
  rank: Int
  vip: Int
  online: Boolean
  verified: Int
  home: Int
  volume: Int
  appearOffline: Boolean
  allowTrade: Boolean
  allowGifts: Boolean
  allowMimic: Boolean
  allowFollow: Boolean
  allowWhisper: Boolean
  allowFriendRequests: Boolean
  allowBotSpeech: Boolean
  allowPetSpeech: Boolean
}

input HabboUpdateManyMutationInput {
  username: String
  motto: String
  gender: Gender
  figure: String
  rank: Int
  vip: Int
  online: Boolean
  verified: Int
  home: Int
  volume: Int
  appearOffline: Boolean
  allowTrade: Boolean
  allowGifts: Boolean
  allowMimic: Boolean
  allowFollow: Boolean
  allowWhisper: Boolean
  allowFriendRequests: Boolean
  allowBotSpeech: Boolean
  allowPetSpeech: Boolean
}

input HabboUpdateManyWithoutUserInput {
  create: [HabboCreateWithoutUserInput!]
  delete: [HabboWhereUniqueInput!]
  connect: [HabboWhereUniqueInput!]
  set: [HabboWhereUniqueInput!]
  disconnect: [HabboWhereUniqueInput!]
  update: [HabboUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [HabboUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [HabboScalarWhereInput!]
  updateMany: [HabboUpdateManyWithWhereNestedInput!]
}

input HabboUpdateManyWithWhereNestedInput {
  where: HabboScalarWhereInput!
  data: HabboUpdateManyDataInput!
}

input HabboUpdateOneInput {
  create: HabboCreateInput
  update: HabboUpdateDataInput
  upsert: HabboUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: HabboWhereUniqueInput
}

input HabboUpdateOneRequiredInput {
  create: HabboCreateInput
  update: HabboUpdateDataInput
  upsert: HabboUpsertNestedInput
  connect: HabboWhereUniqueInput
}

input HabboUpdateWithoutUserDataInput {
  username: String
  motto: String
  gender: Gender
  figure: String
  rank: Int
  vip: Int
  online: Boolean
  verified: Int
  home: Int
  volume: Int
  appearOffline: Boolean
  allowTrade: Boolean
  allowGifts: Boolean
  allowMimic: Boolean
  allowFollow: Boolean
  allowWhisper: Boolean
  allowFriendRequests: Boolean
  allowBotSpeech: Boolean
  allowPetSpeech: Boolean
}

input HabboUpdateWithWhereUniqueWithoutUserInput {
  where: HabboWhereUniqueInput!
  data: HabboUpdateWithoutUserDataInput!
}

input HabboUpsertNestedInput {
  update: HabboUpdateDataInput!
  create: HabboCreateInput!
}

input HabboUpsertWithWhereUniqueWithoutUserInput {
  where: HabboWhereUniqueInput!
  update: HabboUpdateWithoutUserDataInput!
  create: HabboCreateWithoutUserInput!
}

input HabboWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  motto: String
  motto_not: String
  motto_in: [String!]
  motto_not_in: [String!]
  motto_lt: String
  motto_lte: String
  motto_gt: String
  motto_gte: String
  motto_contains: String
  motto_not_contains: String
  motto_starts_with: String
  motto_not_starts_with: String
  motto_ends_with: String
  motto_not_ends_with: String
  gender: Gender
  gender_not: Gender
  gender_in: [Gender!]
  gender_not_in: [Gender!]
  figure: String
  figure_not: String
  figure_in: [String!]
  figure_not_in: [String!]
  figure_lt: String
  figure_lte: String
  figure_gt: String
  figure_gte: String
  figure_contains: String
  figure_not_contains: String
  figure_starts_with: String
  figure_not_starts_with: String
  figure_ends_with: String
  figure_not_ends_with: String
  rank: Int
  rank_not: Int
  rank_in: [Int!]
  rank_not_in: [Int!]
  rank_lt: Int
  rank_lte: Int
  rank_gt: Int
  rank_gte: Int
  vip: Int
  vip_not: Int
  vip_in: [Int!]
  vip_not_in: [Int!]
  vip_lt: Int
  vip_lte: Int
  vip_gt: Int
  vip_gte: Int
  online: Boolean
  online_not: Boolean
  verified: Int
  verified_not: Int
  verified_in: [Int!]
  verified_not_in: [Int!]
  verified_lt: Int
  verified_lte: Int
  verified_gt: Int
  verified_gte: Int
  home: Int
  home_not: Int
  home_in: [Int!]
  home_not_in: [Int!]
  home_lt: Int
  home_lte: Int
  home_gt: Int
  home_gte: Int
  volume: Int
  volume_not: Int
  volume_in: [Int!]
  volume_not_in: [Int!]
  volume_lt: Int
  volume_lte: Int
  volume_gt: Int
  volume_gte: Int
  appearOffline: Boolean
  appearOffline_not: Boolean
  allowTrade: Boolean
  allowTrade_not: Boolean
  allowGifts: Boolean
  allowGifts_not: Boolean
  allowMimic: Boolean
  allowMimic_not: Boolean
  allowFollow: Boolean
  allowFollow_not: Boolean
  allowWhisper: Boolean
  allowWhisper_not: Boolean
  allowFriendRequests: Boolean
  allowFriendRequests_not: Boolean
  allowBotSpeech: Boolean
  allowBotSpeech_not: Boolean
  allowPetSpeech: Boolean
  allowPetSpeech_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [HabboWhereInput!]
  OR: [HabboWhereInput!]
  NOT: [HabboWhereInput!]
}

input HabboWhereUniqueInput {
  id: ID
  username: String
}

scalar Json

type Language {
  id: ID!
  name: String
  native: String
  code: String!
  enabled: Boolean
}

type LanguageConnection {
  pageInfo: PageInfo!
  edges: [LanguageEdge]!
  aggregate: AggregateLanguage!
}

input LanguageCreateInput {
  id: ID
  name: String
  native: String
  code: String!
  enabled: Boolean
}

input LanguageCreateOneInput {
  create: LanguageCreateInput
  connect: LanguageWhereUniqueInput
}

type LanguageEdge {
  node: Language!
  cursor: String!
}

enum LanguageOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  native_ASC
  native_DESC
  code_ASC
  code_DESC
  enabled_ASC
  enabled_DESC
}

type LanguagePreviousValues {
  id: ID!
  name: String
  native: String
  code: String!
  enabled: Boolean
}

type LanguageSubscriptionPayload {
  mutation: MutationType!
  node: Language
  updatedFields: [String!]
  previousValues: LanguagePreviousValues
}

input LanguageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LanguageWhereInput
  AND: [LanguageSubscriptionWhereInput!]
  OR: [LanguageSubscriptionWhereInput!]
  NOT: [LanguageSubscriptionWhereInput!]
}

input LanguageUpdateDataInput {
  name: String
  native: String
  code: String
  enabled: Boolean
}

input LanguageUpdateInput {
  name: String
  native: String
  code: String
  enabled: Boolean
}

input LanguageUpdateManyMutationInput {
  name: String
  native: String
  code: String
  enabled: Boolean
}

input LanguageUpdateOneInput {
  create: LanguageCreateInput
  update: LanguageUpdateDataInput
  upsert: LanguageUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: LanguageWhereUniqueInput
}

input LanguageUpsertNestedInput {
  update: LanguageUpdateDataInput!
  create: LanguageCreateInput!
}

input LanguageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  native: String
  native_not: String
  native_in: [String!]
  native_not_in: [String!]
  native_lt: String
  native_lte: String
  native_gt: String
  native_gte: String
  native_contains: String
  native_not_contains: String
  native_starts_with: String
  native_not_starts_with: String
  native_ends_with: String
  native_not_ends_with: String
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  enabled: Boolean
  enabled_not: Boolean
  AND: [LanguageWhereInput!]
  OR: [LanguageWhereInput!]
  NOT: [LanguageWhereInput!]
}

input LanguageWhereUniqueInput {
  id: ID
  code: String
}

scalar Long

type Mutation {
  createBadge(data: BadgeCreateInput!): Badge!
  updateBadge(data: BadgeUpdateInput!, where: BadgeWhereUniqueInput!): Badge
  updateManyBadges(data: BadgeUpdateManyMutationInput!, where: BadgeWhereInput): BatchPayload!
  upsertBadge(where: BadgeWhereUniqueInput!, create: BadgeCreateInput!, update: BadgeUpdateInput!): Badge!
  deleteBadge(where: BadgeWhereUniqueInput!): Badge
  deleteManyBadges(where: BadgeWhereInput): BatchPayload!
  createBan(data: BanCreateInput!): Ban!
  updateBan(data: BanUpdateInput!, where: BanWhereUniqueInput!): Ban
  updateManyBans(data: BanUpdateManyMutationInput!, where: BanWhereInput): BatchPayload!
  upsertBan(where: BanWhereUniqueInput!, create: BanCreateInput!, update: BanUpdateInput!): Ban!
  deleteBan(where: BanWhereUniqueInput!): Ban
  deleteManyBans(where: BanWhereInput): BatchPayload!
  createBot(data: BotCreateInput!): Bot!
  updateBot(data: BotUpdateInput!, where: BotWhereUniqueInput!): Bot
  updateManyBots(data: BotUpdateManyMutationInput!, where: BotWhereInput): BatchPayload!
  upsertBot(where: BotWhereUniqueInput!, create: BotCreateInput!, update: BotUpdateInput!): Bot!
  deleteBot(where: BotWhereUniqueInput!): Bot
  deleteManyBots(where: BotWhereInput): BatchPayload!
  createCatalogFeatured(data: CatalogFeaturedCreateInput!): CatalogFeatured!
  updateCatalogFeatured(data: CatalogFeaturedUpdateInput!, where: CatalogFeaturedWhereUniqueInput!): CatalogFeatured
  updateManyCatalogFeatureds(data: CatalogFeaturedUpdateManyMutationInput!, where: CatalogFeaturedWhereInput): BatchPayload!
  upsertCatalogFeatured(where: CatalogFeaturedWhereUniqueInput!, create: CatalogFeaturedCreateInput!, update: CatalogFeaturedUpdateInput!): CatalogFeatured!
  deleteCatalogFeatured(where: CatalogFeaturedWhereUniqueInput!): CatalogFeatured
  deleteManyCatalogFeatureds(where: CatalogFeaturedWhereInput): BatchPayload!
  createCatalogItems(data: CatalogItemsCreateInput!): CatalogItems!
  updateCatalogItems(data: CatalogItemsUpdateInput!, where: CatalogItemsWhereUniqueInput!): CatalogItems
  updateManyCatalogItemses(data: CatalogItemsUpdateManyMutationInput!, where: CatalogItemsWhereInput): BatchPayload!
  upsertCatalogItems(where: CatalogItemsWhereUniqueInput!, create: CatalogItemsCreateInput!, update: CatalogItemsUpdateInput!): CatalogItems!
  deleteCatalogItems(where: CatalogItemsWhereUniqueInput!): CatalogItems
  deleteManyCatalogItemses(where: CatalogItemsWhereInput): BatchPayload!
  createCatalogPage(data: CatalogPageCreateInput!): CatalogPage!
  updateCatalogPage(data: CatalogPageUpdateInput!, where: CatalogPageWhereUniqueInput!): CatalogPage
  updateManyCatalogPages(data: CatalogPageUpdateManyMutationInput!, where: CatalogPageWhereInput): BatchPayload!
  upsertCatalogPage(where: CatalogPageWhereUniqueInput!, create: CatalogPageCreateInput!, update: CatalogPageUpdateInput!): CatalogPage!
  deleteCatalogPage(where: CatalogPageWhereUniqueInput!): CatalogPage
  deleteManyCatalogPages(where: CatalogPageWhereInput): BatchPayload!
  createChatlog(data: ChatlogCreateInput!): Chatlog!
  updateChatlog(data: ChatlogUpdateInput!, where: ChatlogWhereUniqueInput!): Chatlog
  updateManyChatlogs(data: ChatlogUpdateManyMutationInput!, where: ChatlogWhereInput): BatchPayload!
  upsertChatlog(where: ChatlogWhereUniqueInput!, create: ChatlogCreateInput!, update: ChatlogUpdateInput!): Chatlog!
  deleteChatlog(where: ChatlogWhereUniqueInput!): Chatlog
  deleteManyChatlogs(where: ChatlogWhereInput): BatchPayload!
  createChatlogConsole(data: ChatlogConsoleCreateInput!): ChatlogConsole!
  updateChatlogConsole(data: ChatlogConsoleUpdateInput!, where: ChatlogConsoleWhereUniqueInput!): ChatlogConsole
  updateManyChatlogConsoles(data: ChatlogConsoleUpdateManyMutationInput!, where: ChatlogConsoleWhereInput): BatchPayload!
  upsertChatlogConsole(where: ChatlogConsoleWhereUniqueInput!, create: ChatlogConsoleCreateInput!, update: ChatlogConsoleUpdateInput!): ChatlogConsole!
  deleteChatlogConsole(where: ChatlogConsoleWhereUniqueInput!): ChatlogConsole
  deleteManyChatlogConsoles(where: ChatlogConsoleWhereInput): BatchPayload!
  createChatlogConsoleInvitations(data: ChatlogConsoleInvitationsCreateInput!): ChatlogConsoleInvitations!
  updateChatlogConsoleInvitations(data: ChatlogConsoleInvitationsUpdateInput!, where: ChatlogConsoleInvitationsWhereUniqueInput!): ChatlogConsoleInvitations
  updateManyChatlogConsoleInvitationses(data: ChatlogConsoleInvitationsUpdateManyMutationInput!, where: ChatlogConsoleInvitationsWhereInput): BatchPayload!
  upsertChatlogConsoleInvitations(where: ChatlogConsoleInvitationsWhereUniqueInput!, create: ChatlogConsoleInvitationsCreateInput!, update: ChatlogConsoleInvitationsUpdateInput!): ChatlogConsoleInvitations!
  deleteChatlogConsoleInvitations(where: ChatlogConsoleInvitationsWhereUniqueInput!): ChatlogConsoleInvitations
  deleteManyChatlogConsoleInvitationses(where: ChatlogConsoleInvitationsWhereInput): BatchPayload!
  createCurrencies(data: CurrenciesCreateInput!): Currencies!
  updateCurrencies(data: CurrenciesUpdateInput!, where: CurrenciesWhereUniqueInput!): Currencies
  updateManyCurrencieses(data: CurrenciesUpdateManyMutationInput!, where: CurrenciesWhereInput): BatchPayload!
  upsertCurrencies(where: CurrenciesWhereUniqueInput!, create: CurrenciesCreateInput!, update: CurrenciesUpdateInput!): Currencies!
  deleteCurrencies(where: CurrenciesWhereUniqueInput!): Currencies
  deleteManyCurrencieses(where: CurrenciesWhereInput): BatchPayload!
  createHabbo(data: HabboCreateInput!): Habbo!
  updateHabbo(data: HabboUpdateInput!, where: HabboWhereUniqueInput!): Habbo
  updateManyHabboes(data: HabboUpdateManyMutationInput!, where: HabboWhereInput): BatchPayload!
  upsertHabbo(where: HabboWhereUniqueInput!, create: HabboCreateInput!, update: HabboUpdateInput!): Habbo!
  deleteHabbo(where: HabboWhereUniqueInput!): Habbo
  deleteManyHabboes(where: HabboWhereInput): BatchPayload!
  createLanguage(data: LanguageCreateInput!): Language!
  updateLanguage(data: LanguageUpdateInput!, where: LanguageWhereUniqueInput!): Language
  updateManyLanguages(data: LanguageUpdateManyMutationInput!, where: LanguageWhereInput): BatchPayload!
  upsertLanguage(where: LanguageWhereUniqueInput!, create: LanguageCreateInput!, update: LanguageUpdateInput!): Language!
  deleteLanguage(where: LanguageWhereUniqueInput!): Language
  deleteManyLanguages(where: LanguageWhereInput): BatchPayload!
  createNavigatorCategory(data: NavigatorCategoryCreateInput!): NavigatorCategory!
  updateNavigatorCategory(data: NavigatorCategoryUpdateInput!, where: NavigatorCategoryWhereUniqueInput!): NavigatorCategory
  updateManyNavigatorCategories(data: NavigatorCategoryUpdateManyMutationInput!, where: NavigatorCategoryWhereInput): BatchPayload!
  upsertNavigatorCategory(where: NavigatorCategoryWhereUniqueInput!, create: NavigatorCategoryCreateInput!, update: NavigatorCategoryUpdateInput!): NavigatorCategory!
  deleteNavigatorCategory(where: NavigatorCategoryWhereUniqueInput!): NavigatorCategory
  deleteManyNavigatorCategories(where: NavigatorCategoryWhereInput): BatchPayload!
  createNavigatorTab(data: NavigatorTabCreateInput!): NavigatorTab!
  updateNavigatorTab(data: NavigatorTabUpdateInput!, where: NavigatorTabWhereUniqueInput!): NavigatorTab
  updateManyNavigatorTabs(data: NavigatorTabUpdateManyMutationInput!, where: NavigatorTabWhereInput): BatchPayload!
  upsertNavigatorTab(where: NavigatorTabWhereUniqueInput!, create: NavigatorTabCreateInput!, update: NavigatorTabUpdateInput!): NavigatorTab!
  deleteNavigatorTab(where: NavigatorTabWhereUniqueInput!): NavigatorTab
  deleteManyNavigatorTabs(where: NavigatorTabWhereInput): BatchPayload!
  createNews(data: NewsCreateInput!): News!
  updateNews(data: NewsUpdateInput!, where: NewsWhereUniqueInput!): News
  updateManyNewses(data: NewsUpdateManyMutationInput!, where: NewsWhereInput): BatchPayload!
  upsertNews(where: NewsWhereUniqueInput!, create: NewsCreateInput!, update: NewsUpdateInput!): News!
  deleteNews(where: NewsWhereUniqueInput!): News
  deleteManyNewses(where: NewsWhereInput): BatchPayload!
  createRank(data: RankCreateInput!): Rank!
  updateRank(data: RankUpdateInput!, where: RankWhereUniqueInput!): Rank
  updateManyRanks(data: RankUpdateManyMutationInput!, where: RankWhereInput): BatchPayload!
  upsertRank(where: RankWhereUniqueInput!, create: RankCreateInput!, update: RankUpdateInput!): Rank!
  deleteRank(where: RankWhereUniqueInput!): Rank
  deleteManyRanks(where: RankWhereInput): BatchPayload!
  createRoom(data: RoomCreateInput!): Room!
  updateRoom(data: RoomUpdateInput!, where: RoomWhereUniqueInput!): Room
  updateManyRooms(data: RoomUpdateManyMutationInput!, where: RoomWhereInput): BatchPayload!
  upsertRoom(where: RoomWhereUniqueInput!, create: RoomCreateInput!, update: RoomUpdateInput!): Room!
  deleteRoom(where: RoomWhereUniqueInput!): Room
  deleteManyRooms(where: RoomWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

type NavigatorCategory {
  id: ID!
  name: String
  order: Int
  parent: NavigatorTab
}

type NavigatorCategoryConnection {
  pageInfo: PageInfo!
  edges: [NavigatorCategoryEdge]!
  aggregate: AggregateNavigatorCategory!
}

input NavigatorCategoryCreateInput {
  id: ID
  name: String
  order: Int
  parent: NavigatorTabCreateOneWithoutCategoriesInput
}

input NavigatorCategoryCreateManyWithoutParentInput {
  create: [NavigatorCategoryCreateWithoutParentInput!]
  connect: [NavigatorCategoryWhereUniqueInput!]
}

input NavigatorCategoryCreateWithoutParentInput {
  id: ID
  name: String
  order: Int
}

type NavigatorCategoryEdge {
  node: NavigatorCategory!
  cursor: String!
}

enum NavigatorCategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  order_ASC
  order_DESC
}

type NavigatorCategoryPreviousValues {
  id: ID!
  name: String
  order: Int
}

input NavigatorCategoryScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  AND: [NavigatorCategoryScalarWhereInput!]
  OR: [NavigatorCategoryScalarWhereInput!]
  NOT: [NavigatorCategoryScalarWhereInput!]
}

type NavigatorCategorySubscriptionPayload {
  mutation: MutationType!
  node: NavigatorCategory
  updatedFields: [String!]
  previousValues: NavigatorCategoryPreviousValues
}

input NavigatorCategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NavigatorCategoryWhereInput
  AND: [NavigatorCategorySubscriptionWhereInput!]
  OR: [NavigatorCategorySubscriptionWhereInput!]
  NOT: [NavigatorCategorySubscriptionWhereInput!]
}

input NavigatorCategoryUpdateInput {
  name: String
  order: Int
  parent: NavigatorTabUpdateOneWithoutCategoriesInput
}

input NavigatorCategoryUpdateManyDataInput {
  name: String
  order: Int
}

input NavigatorCategoryUpdateManyMutationInput {
  name: String
  order: Int
}

input NavigatorCategoryUpdateManyWithoutParentInput {
  create: [NavigatorCategoryCreateWithoutParentInput!]
  delete: [NavigatorCategoryWhereUniqueInput!]
  connect: [NavigatorCategoryWhereUniqueInput!]
  set: [NavigatorCategoryWhereUniqueInput!]
  disconnect: [NavigatorCategoryWhereUniqueInput!]
  update: [NavigatorCategoryUpdateWithWhereUniqueWithoutParentInput!]
  upsert: [NavigatorCategoryUpsertWithWhereUniqueWithoutParentInput!]
  deleteMany: [NavigatorCategoryScalarWhereInput!]
  updateMany: [NavigatorCategoryUpdateManyWithWhereNestedInput!]
}

input NavigatorCategoryUpdateManyWithWhereNestedInput {
  where: NavigatorCategoryScalarWhereInput!
  data: NavigatorCategoryUpdateManyDataInput!
}

input NavigatorCategoryUpdateWithoutParentDataInput {
  name: String
  order: Int
}

input NavigatorCategoryUpdateWithWhereUniqueWithoutParentInput {
  where: NavigatorCategoryWhereUniqueInput!
  data: NavigatorCategoryUpdateWithoutParentDataInput!
}

input NavigatorCategoryUpsertWithWhereUniqueWithoutParentInput {
  where: NavigatorCategoryWhereUniqueInput!
  update: NavigatorCategoryUpdateWithoutParentDataInput!
  create: NavigatorCategoryCreateWithoutParentInput!
}

input NavigatorCategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  parent: NavigatorTabWhereInput
  AND: [NavigatorCategoryWhereInput!]
  OR: [NavigatorCategoryWhereInput!]
  NOT: [NavigatorCategoryWhereInput!]
}

input NavigatorCategoryWhereUniqueInput {
  id: ID
}

type NavigatorTab {
  id: ID!
  name: String
  order: Int
  language: Language
  categories(where: NavigatorCategoryWhereInput, orderBy: NavigatorCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NavigatorCategory!]
}

type NavigatorTabConnection {
  pageInfo: PageInfo!
  edges: [NavigatorTabEdge]!
  aggregate: AggregateNavigatorTab!
}

input NavigatorTabCreateInput {
  id: ID
  name: String
  order: Int
  language: LanguageCreateOneInput
  categories: NavigatorCategoryCreateManyWithoutParentInput
}

input NavigatorTabCreateOneWithoutCategoriesInput {
  create: NavigatorTabCreateWithoutCategoriesInput
  connect: NavigatorTabWhereUniqueInput
}

input NavigatorTabCreateWithoutCategoriesInput {
  id: ID
  name: String
  order: Int
  language: LanguageCreateOneInput
}

type NavigatorTabEdge {
  node: NavigatorTab!
  cursor: String!
}

enum NavigatorTabOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  order_ASC
  order_DESC
}

type NavigatorTabPreviousValues {
  id: ID!
  name: String
  order: Int
}

type NavigatorTabSubscriptionPayload {
  mutation: MutationType!
  node: NavigatorTab
  updatedFields: [String!]
  previousValues: NavigatorTabPreviousValues
}

input NavigatorTabSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NavigatorTabWhereInput
  AND: [NavigatorTabSubscriptionWhereInput!]
  OR: [NavigatorTabSubscriptionWhereInput!]
  NOT: [NavigatorTabSubscriptionWhereInput!]
}

input NavigatorTabUpdateInput {
  name: String
  order: Int
  language: LanguageUpdateOneInput
  categories: NavigatorCategoryUpdateManyWithoutParentInput
}

input NavigatorTabUpdateManyMutationInput {
  name: String
  order: Int
}

input NavigatorTabUpdateOneWithoutCategoriesInput {
  create: NavigatorTabCreateWithoutCategoriesInput
  update: NavigatorTabUpdateWithoutCategoriesDataInput
  upsert: NavigatorTabUpsertWithoutCategoriesInput
  delete: Boolean
  disconnect: Boolean
  connect: NavigatorTabWhereUniqueInput
}

input NavigatorTabUpdateWithoutCategoriesDataInput {
  name: String
  order: Int
  language: LanguageUpdateOneInput
}

input NavigatorTabUpsertWithoutCategoriesInput {
  update: NavigatorTabUpdateWithoutCategoriesDataInput!
  create: NavigatorTabCreateWithoutCategoriesInput!
}

input NavigatorTabWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  language: LanguageWhereInput
  categories_every: NavigatorCategoryWhereInput
  categories_some: NavigatorCategoryWhereInput
  categories_none: NavigatorCategoryWhereInput
  AND: [NavigatorTabWhereInput!]
  OR: [NavigatorTabWhereInput!]
  NOT: [NavigatorTabWhereInput!]
}

input NavigatorTabWhereUniqueInput {
  id: ID
}

type News {
  id: ID!
  title: String
  summary: String
  body: String
  image: String
  author: User
  createdAt: DateTime
  updatedAt: DateTime
}

type NewsConnection {
  pageInfo: PageInfo!
  edges: [NewsEdge]!
  aggregate: AggregateNews!
}

input NewsCreateInput {
  id: ID
  title: String
  summary: String
  body: String
  image: String
  author: UserCreateOneInput
}

type NewsEdge {
  node: News!
  cursor: String!
}

enum NewsOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  summary_ASC
  summary_DESC
  body_ASC
  body_DESC
  image_ASC
  image_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type NewsPreviousValues {
  id: ID!
  title: String
  summary: String
  body: String
  image: String
  createdAt: DateTime
  updatedAt: DateTime
}

type NewsSubscriptionPayload {
  mutation: MutationType!
  node: News
  updatedFields: [String!]
  previousValues: NewsPreviousValues
}

input NewsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NewsWhereInput
  AND: [NewsSubscriptionWhereInput!]
  OR: [NewsSubscriptionWhereInput!]
  NOT: [NewsSubscriptionWhereInput!]
}

input NewsUpdateInput {
  title: String
  summary: String
  body: String
  image: String
  author: UserUpdateOneInput
}

input NewsUpdateManyMutationInput {
  title: String
  summary: String
  body: String
  image: String
}

input NewsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  summary: String
  summary_not: String
  summary_in: [String!]
  summary_not_in: [String!]
  summary_lt: String
  summary_lte: String
  summary_gt: String
  summary_gte: String
  summary_contains: String
  summary_not_contains: String
  summary_starts_with: String
  summary_not_starts_with: String
  summary_ends_with: String
  summary_not_ends_with: String
  body: String
  body_not: String
  body_in: [String!]
  body_not_in: [String!]
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  author: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [NewsWhereInput!]
  OR: [NewsWhereInput!]
  NOT: [NewsWhereInput!]
}

input NewsWhereUniqueInput {
  id: ID
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  badge(where: BadgeWhereUniqueInput!): Badge
  badges(where: BadgeWhereInput, orderBy: BadgeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Badge]!
  badgesConnection(where: BadgeWhereInput, orderBy: BadgeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BadgeConnection!
  ban(where: BanWhereUniqueInput!): Ban
  bans(where: BanWhereInput, orderBy: BanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ban]!
  bansConnection(where: BanWhereInput, orderBy: BanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BanConnection!
  bot(where: BotWhereUniqueInput!): Bot
  bots(where: BotWhereInput, orderBy: BotOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Bot]!
  botsConnection(where: BotWhereInput, orderBy: BotOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BotConnection!
  catalogFeatured(where: CatalogFeaturedWhereUniqueInput!): CatalogFeatured
  catalogFeatureds(where: CatalogFeaturedWhereInput, orderBy: CatalogFeaturedOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CatalogFeatured]!
  catalogFeaturedsConnection(where: CatalogFeaturedWhereInput, orderBy: CatalogFeaturedOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CatalogFeaturedConnection!
  catalogItems(where: CatalogItemsWhereUniqueInput!): CatalogItems
  catalogItemses(where: CatalogItemsWhereInput, orderBy: CatalogItemsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CatalogItems]!
  catalogItemsesConnection(where: CatalogItemsWhereInput, orderBy: CatalogItemsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CatalogItemsConnection!
  catalogPage(where: CatalogPageWhereUniqueInput!): CatalogPage
  catalogPages(where: CatalogPageWhereInput, orderBy: CatalogPageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CatalogPage]!
  catalogPagesConnection(where: CatalogPageWhereInput, orderBy: CatalogPageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CatalogPageConnection!
  chatlog(where: ChatlogWhereUniqueInput!): Chatlog
  chatlogs(where: ChatlogWhereInput, orderBy: ChatlogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Chatlog]!
  chatlogsConnection(where: ChatlogWhereInput, orderBy: ChatlogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ChatlogConnection!
  chatlogConsole(where: ChatlogConsoleWhereUniqueInput!): ChatlogConsole
  chatlogConsoles(where: ChatlogConsoleWhereInput, orderBy: ChatlogConsoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChatlogConsole]!
  chatlogConsolesConnection(where: ChatlogConsoleWhereInput, orderBy: ChatlogConsoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ChatlogConsoleConnection!
  chatlogConsoleInvitations(where: ChatlogConsoleInvitationsWhereUniqueInput!): ChatlogConsoleInvitations
  chatlogConsoleInvitationses(where: ChatlogConsoleInvitationsWhereInput, orderBy: ChatlogConsoleInvitationsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChatlogConsoleInvitations]!
  chatlogConsoleInvitationsesConnection(where: ChatlogConsoleInvitationsWhereInput, orderBy: ChatlogConsoleInvitationsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ChatlogConsoleInvitationsConnection!
  currencies(where: CurrenciesWhereUniqueInput!): Currencies
  currencieses(where: CurrenciesWhereInput, orderBy: CurrenciesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Currencies]!
  currenciesesConnection(where: CurrenciesWhereInput, orderBy: CurrenciesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CurrenciesConnection!
  habbo(where: HabboWhereUniqueInput!): Habbo
  habboes(where: HabboWhereInput, orderBy: HabboOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Habbo]!
  habboesConnection(where: HabboWhereInput, orderBy: HabboOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HabboConnection!
  language(where: LanguageWhereUniqueInput!): Language
  languages(where: LanguageWhereInput, orderBy: LanguageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Language]!
  languagesConnection(where: LanguageWhereInput, orderBy: LanguageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LanguageConnection!
  navigatorCategory(where: NavigatorCategoryWhereUniqueInput!): NavigatorCategory
  navigatorCategories(where: NavigatorCategoryWhereInput, orderBy: NavigatorCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NavigatorCategory]!
  navigatorCategoriesConnection(where: NavigatorCategoryWhereInput, orderBy: NavigatorCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NavigatorCategoryConnection!
  navigatorTab(where: NavigatorTabWhereUniqueInput!): NavigatorTab
  navigatorTabs(where: NavigatorTabWhereInput, orderBy: NavigatorTabOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NavigatorTab]!
  navigatorTabsConnection(where: NavigatorTabWhereInput, orderBy: NavigatorTabOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NavigatorTabConnection!
  news(where: NewsWhereUniqueInput!): News
  newses(where: NewsWhereInput, orderBy: NewsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [News]!
  newsesConnection(where: NewsWhereInput, orderBy: NewsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NewsConnection!
  rank(where: RankWhereUniqueInput!): Rank
  ranks(where: RankWhereInput, orderBy: RankOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Rank]!
  ranksConnection(where: RankWhereInput, orderBy: RankOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RankConnection!
  room(where: RoomWhereUniqueInput!): Room
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room]!
  roomsConnection(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoomConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Rank {
  id: ID!
  order: Int!
  name: String!
}

type RankConnection {
  pageInfo: PageInfo!
  edges: [RankEdge]!
  aggregate: AggregateRank!
}

input RankCreateInput {
  id: ID
  order: Int!
  name: String!
}

type RankEdge {
  node: Rank!
  cursor: String!
}

enum RankOrderByInput {
  id_ASC
  id_DESC
  order_ASC
  order_DESC
  name_ASC
  name_DESC
}

type RankPreviousValues {
  id: ID!
  order: Int!
  name: String!
}

type RankSubscriptionPayload {
  mutation: MutationType!
  node: Rank
  updatedFields: [String!]
  previousValues: RankPreviousValues
}

input RankSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RankWhereInput
  AND: [RankSubscriptionWhereInput!]
  OR: [RankSubscriptionWhereInput!]
  NOT: [RankSubscriptionWhereInput!]
}

input RankUpdateInput {
  order: Int
  name: String
}

input RankUpdateManyMutationInput {
  order: Int
  name: String
}

input RankWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [RankWhereInput!]
  OR: [RankWhereInput!]
  NOT: [RankWhereInput!]
}

input RankWhereUniqueInput {
  id: ID
}

type Room {
  id: ID!
  name: String!
  description: String
  type: roomType
  category: Int
  owner: Habbo
  map: Json
  floorThickness: Float
  wallThickness: Float
  wallHeight: Float
  hideWalls: Boolean
  hideWired: Boolean
  currentUsers: Int
  maxUsers: Int
  allowPets: Boolean
  allowPetsEating: Boolean
}

type RoomConnection {
  pageInfo: PageInfo!
  edges: [RoomEdge]!
  aggregate: AggregateRoom!
}

input RoomCreateInput {
  id: ID
  name: String!
  description: String
  type: roomType
  category: Int
  owner: HabboCreateOneInput
  map: Json
  floorThickness: Float
  wallThickness: Float
  wallHeight: Float
  hideWalls: Boolean
  hideWired: Boolean
  currentUsers: Int
  maxUsers: Int
  allowPets: Boolean
  allowPetsEating: Boolean
}

input RoomCreateOneInput {
  create: RoomCreateInput
  connect: RoomWhereUniqueInput
}

type RoomEdge {
  node: Room!
  cursor: String!
}

enum RoomOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  type_ASC
  type_DESC
  category_ASC
  category_DESC
  map_ASC
  map_DESC
  floorThickness_ASC
  floorThickness_DESC
  wallThickness_ASC
  wallThickness_DESC
  wallHeight_ASC
  wallHeight_DESC
  hideWalls_ASC
  hideWalls_DESC
  hideWired_ASC
  hideWired_DESC
  currentUsers_ASC
  currentUsers_DESC
  maxUsers_ASC
  maxUsers_DESC
  allowPets_ASC
  allowPets_DESC
  allowPetsEating_ASC
  allowPetsEating_DESC
}

type RoomPreviousValues {
  id: ID!
  name: String!
  description: String
  type: roomType
  category: Int
  map: Json
  floorThickness: Float
  wallThickness: Float
  wallHeight: Float
  hideWalls: Boolean
  hideWired: Boolean
  currentUsers: Int
  maxUsers: Int
  allowPets: Boolean
  allowPetsEating: Boolean
}

type RoomSubscriptionPayload {
  mutation: MutationType!
  node: Room
  updatedFields: [String!]
  previousValues: RoomPreviousValues
}

input RoomSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoomWhereInput
  AND: [RoomSubscriptionWhereInput!]
  OR: [RoomSubscriptionWhereInput!]
  NOT: [RoomSubscriptionWhereInput!]
}

enum roomType {
  PUBLIC
  LOCKED
  PASSWORD
  HIDDEN
}

input RoomUpdateDataInput {
  name: String
  description: String
  type: roomType
  category: Int
  owner: HabboUpdateOneInput
  map: Json
  floorThickness: Float
  wallThickness: Float
  wallHeight: Float
  hideWalls: Boolean
  hideWired: Boolean
  currentUsers: Int
  maxUsers: Int
  allowPets: Boolean
  allowPetsEating: Boolean
}

input RoomUpdateInput {
  name: String
  description: String
  type: roomType
  category: Int
  owner: HabboUpdateOneInput
  map: Json
  floorThickness: Float
  wallThickness: Float
  wallHeight: Float
  hideWalls: Boolean
  hideWired: Boolean
  currentUsers: Int
  maxUsers: Int
  allowPets: Boolean
  allowPetsEating: Boolean
}

input RoomUpdateManyMutationInput {
  name: String
  description: String
  type: roomType
  category: Int
  map: Json
  floorThickness: Float
  wallThickness: Float
  wallHeight: Float
  hideWalls: Boolean
  hideWired: Boolean
  currentUsers: Int
  maxUsers: Int
  allowPets: Boolean
  allowPetsEating: Boolean
}

input RoomUpdateOneRequiredInput {
  create: RoomCreateInput
  update: RoomUpdateDataInput
  upsert: RoomUpsertNestedInput
  connect: RoomWhereUniqueInput
}

input RoomUpsertNestedInput {
  update: RoomUpdateDataInput!
  create: RoomCreateInput!
}

input RoomWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  type: roomType
  type_not: roomType
  type_in: [roomType!]
  type_not_in: [roomType!]
  category: Int
  category_not: Int
  category_in: [Int!]
  category_not_in: [Int!]
  category_lt: Int
  category_lte: Int
  category_gt: Int
  category_gte: Int
  owner: HabboWhereInput
  floorThickness: Float
  floorThickness_not: Float
  floorThickness_in: [Float!]
  floorThickness_not_in: [Float!]
  floorThickness_lt: Float
  floorThickness_lte: Float
  floorThickness_gt: Float
  floorThickness_gte: Float
  wallThickness: Float
  wallThickness_not: Float
  wallThickness_in: [Float!]
  wallThickness_not_in: [Float!]
  wallThickness_lt: Float
  wallThickness_lte: Float
  wallThickness_gt: Float
  wallThickness_gte: Float
  wallHeight: Float
  wallHeight_not: Float
  wallHeight_in: [Float!]
  wallHeight_not_in: [Float!]
  wallHeight_lt: Float
  wallHeight_lte: Float
  wallHeight_gt: Float
  wallHeight_gte: Float
  hideWalls: Boolean
  hideWalls_not: Boolean
  hideWired: Boolean
  hideWired_not: Boolean
  currentUsers: Int
  currentUsers_not: Int
  currentUsers_in: [Int!]
  currentUsers_not_in: [Int!]
  currentUsers_lt: Int
  currentUsers_lte: Int
  currentUsers_gt: Int
  currentUsers_gte: Int
  maxUsers: Int
  maxUsers_not: Int
  maxUsers_in: [Int!]
  maxUsers_not_in: [Int!]
  maxUsers_lt: Int
  maxUsers_lte: Int
  maxUsers_gt: Int
  maxUsers_gte: Int
  allowPets: Boolean
  allowPets_not: Boolean
  allowPetsEating: Boolean
  allowPetsEating_not: Boolean
  AND: [RoomWhereInput!]
  OR: [RoomWhereInput!]
  NOT: [RoomWhereInput!]
}

input RoomWhereUniqueInput {
  id: ID
}

type Subscription {
  badge(where: BadgeSubscriptionWhereInput): BadgeSubscriptionPayload
  ban(where: BanSubscriptionWhereInput): BanSubscriptionPayload
  bot(where: BotSubscriptionWhereInput): BotSubscriptionPayload
  catalogFeatured(where: CatalogFeaturedSubscriptionWhereInput): CatalogFeaturedSubscriptionPayload
  catalogItems(where: CatalogItemsSubscriptionWhereInput): CatalogItemsSubscriptionPayload
  catalogPage(where: CatalogPageSubscriptionWhereInput): CatalogPageSubscriptionPayload
  chatlog(where: ChatlogSubscriptionWhereInput): ChatlogSubscriptionPayload
  chatlogConsole(where: ChatlogConsoleSubscriptionWhereInput): ChatlogConsoleSubscriptionPayload
  chatlogConsoleInvitations(where: ChatlogConsoleInvitationsSubscriptionWhereInput): ChatlogConsoleInvitationsSubscriptionPayload
  currencies(where: CurrenciesSubscriptionWhereInput): CurrenciesSubscriptionPayload
  habbo(where: HabboSubscriptionWhereInput): HabboSubscriptionPayload
  language(where: LanguageSubscriptionWhereInput): LanguageSubscriptionPayload
  navigatorCategory(where: NavigatorCategorySubscriptionWhereInput): NavigatorCategorySubscriptionPayload
  navigatorTab(where: NavigatorTabSubscriptionWhereInput): NavigatorTabSubscriptionPayload
  news(where: NewsSubscriptionWhereInput): NewsSubscriptionPayload
  rank(where: RankSubscriptionWhereInput): RankSubscriptionPayload
  room(where: RoomSubscriptionWhereInput): RoomSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  email: String
  password: String
  pin: Int
  habbos(where: HabboWhereInput, orderBy: HabboOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Habbo!]
  createdAt: DateTime
  updatedAt: DateTime
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String
  password: String
  pin: Int
  habbos: HabboCreateManyWithoutUserInput
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutHabbosInput {
  create: UserCreateWithoutHabbosInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutHabbosInput {
  id: ID
  email: String
  password: String
  pin: Int
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  pin_ASC
  pin_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  email: String
  password: String
  pin: Int
  createdAt: DateTime
  updatedAt: DateTime
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  email: String
  password: String
  pin: Int
  habbos: HabboUpdateManyWithoutUserInput
}

input UserUpdateInput {
  email: String
  password: String
  pin: Int
  habbos: HabboUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  email: String
  password: String
  pin: Int
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutHabbosInput {
  create: UserCreateWithoutHabbosInput
  update: UserUpdateWithoutHabbosDataInput
  upsert: UserUpsertWithoutHabbosInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutHabbosDataInput {
  email: String
  password: String
  pin: Int
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutHabbosInput {
  update: UserUpdateWithoutHabbosDataInput!
  create: UserCreateWithoutHabbosInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  pin: Int
  pin_not: Int
  pin_in: [Int!]
  pin_not_in: [Int!]
  pin_lt: Int
  pin_lte: Int
  pin_gt: Int
  pin_gte: Int
  habbos_every: HabboWhereInput
  habbos_some: HabboWhereInput
  habbos_none: HabboWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}
`
      }
    