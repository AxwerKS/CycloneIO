// Code generated by Prisma (prisma@1.31.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  badge: (where?: BadgeWhereInput) => Promise<boolean>;
  ban: (where?: BanWhereInput) => Promise<boolean>;
  bot: (where?: BotWhereInput) => Promise<boolean>;
  catalogItem: (where?: CatalogItemWhereInput) => Promise<boolean>;
  currencies: (where?: CurrenciesWhereInput) => Promise<boolean>;
  room: (where?: RoomWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  badge: (where: BadgeWhereUniqueInput) => BadgePromise;
  badges: (args?: {
    where?: BadgeWhereInput;
    orderBy?: BadgeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Badge>;
  badgesConnection: (args?: {
    where?: BadgeWhereInput;
    orderBy?: BadgeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BadgeConnectionPromise;
  ban: (where: BanWhereUniqueInput) => BanPromise;
  bans: (args?: {
    where?: BanWhereInput;
    orderBy?: BanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Ban>;
  bansConnection: (args?: {
    where?: BanWhereInput;
    orderBy?: BanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BanConnectionPromise;
  bot: (where: BotWhereUniqueInput) => BotPromise;
  bots: (args?: {
    where?: BotWhereInput;
    orderBy?: BotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Bot>;
  botsConnection: (args?: {
    where?: BotWhereInput;
    orderBy?: BotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BotConnectionPromise;
  catalogItem: (where: CatalogItemWhereUniqueInput) => CatalogItemPromise;
  catalogItems: (args?: {
    where?: CatalogItemWhereInput;
    orderBy?: CatalogItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CatalogItem>;
  catalogItemsConnection: (args?: {
    where?: CatalogItemWhereInput;
    orderBy?: CatalogItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CatalogItemConnectionPromise;
  currencies: (where: CurrenciesWhereUniqueInput) => CurrenciesPromise;
  currencieses: (args?: {
    where?: CurrenciesWhereInput;
    orderBy?: CurrenciesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Currencies>;
  currenciesesConnection: (args?: {
    where?: CurrenciesWhereInput;
    orderBy?: CurrenciesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CurrenciesConnectionPromise;
  room: (where: RoomWhereUniqueInput) => RoomPromise;
  rooms: (args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Room>;
  roomsConnection: (args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RoomConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBadge: (data: BadgeCreateInput) => BadgePromise;
  updateBadge: (args: {
    data: BadgeUpdateInput;
    where: BadgeWhereUniqueInput;
  }) => BadgePromise;
  updateManyBadges: (args: {
    data: BadgeUpdateManyMutationInput;
    where?: BadgeWhereInput;
  }) => BatchPayloadPromise;
  upsertBadge: (args: {
    where: BadgeWhereUniqueInput;
    create: BadgeCreateInput;
    update: BadgeUpdateInput;
  }) => BadgePromise;
  deleteBadge: (where: BadgeWhereUniqueInput) => BadgePromise;
  deleteManyBadges: (where?: BadgeWhereInput) => BatchPayloadPromise;
  createBan: (data: BanCreateInput) => BanPromise;
  updateBan: (args: {
    data: BanUpdateInput;
    where: BanWhereUniqueInput;
  }) => BanPromise;
  updateManyBans: (args: {
    data: BanUpdateManyMutationInput;
    where?: BanWhereInput;
  }) => BatchPayloadPromise;
  upsertBan: (args: {
    where: BanWhereUniqueInput;
    create: BanCreateInput;
    update: BanUpdateInput;
  }) => BanPromise;
  deleteBan: (where: BanWhereUniqueInput) => BanPromise;
  deleteManyBans: (where?: BanWhereInput) => BatchPayloadPromise;
  createBot: (data: BotCreateInput) => BotPromise;
  updateBot: (args: {
    data: BotUpdateInput;
    where: BotWhereUniqueInput;
  }) => BotPromise;
  updateManyBots: (args: {
    data: BotUpdateManyMutationInput;
    where?: BotWhereInput;
  }) => BatchPayloadPromise;
  upsertBot: (args: {
    where: BotWhereUniqueInput;
    create: BotCreateInput;
    update: BotUpdateInput;
  }) => BotPromise;
  deleteBot: (where: BotWhereUniqueInput) => BotPromise;
  deleteManyBots: (where?: BotWhereInput) => BatchPayloadPromise;
  createCatalogItem: (data: CatalogItemCreateInput) => CatalogItemPromise;
  updateCatalogItem: (args: {
    data: CatalogItemUpdateInput;
    where: CatalogItemWhereUniqueInput;
  }) => CatalogItemPromise;
  updateManyCatalogItems: (args: {
    data: CatalogItemUpdateManyMutationInput;
    where?: CatalogItemWhereInput;
  }) => BatchPayloadPromise;
  upsertCatalogItem: (args: {
    where: CatalogItemWhereUniqueInput;
    create: CatalogItemCreateInput;
    update: CatalogItemUpdateInput;
  }) => CatalogItemPromise;
  deleteCatalogItem: (where: CatalogItemWhereUniqueInput) => CatalogItemPromise;
  deleteManyCatalogItems: (
    where?: CatalogItemWhereInput
  ) => BatchPayloadPromise;
  createCurrencies: (data: CurrenciesCreateInput) => CurrenciesPromise;
  updateCurrencies: (args: {
    data: CurrenciesUpdateInput;
    where: CurrenciesWhereUniqueInput;
  }) => CurrenciesPromise;
  updateManyCurrencieses: (args: {
    data: CurrenciesUpdateManyMutationInput;
    where?: CurrenciesWhereInput;
  }) => BatchPayloadPromise;
  upsertCurrencies: (args: {
    where: CurrenciesWhereUniqueInput;
    create: CurrenciesCreateInput;
    update: CurrenciesUpdateInput;
  }) => CurrenciesPromise;
  deleteCurrencies: (where: CurrenciesWhereUniqueInput) => CurrenciesPromise;
  deleteManyCurrencieses: (where?: CurrenciesWhereInput) => BatchPayloadPromise;
  createRoom: (data: RoomCreateInput) => RoomPromise;
  updateRoom: (args: {
    data: RoomUpdateInput;
    where: RoomWhereUniqueInput;
  }) => RoomPromise;
  updateManyRooms: (args: {
    data: RoomUpdateManyMutationInput;
    where?: RoomWhereInput;
  }) => BatchPayloadPromise;
  upsertRoom: (args: {
    where: RoomWhereUniqueInput;
    create: RoomCreateInput;
    update: RoomUpdateInput;
  }) => RoomPromise;
  deleteRoom: (where: RoomWhereUniqueInput) => RoomPromise;
  deleteManyRooms: (where?: RoomWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  badge: (
    where?: BadgeSubscriptionWhereInput
  ) => BadgeSubscriptionPayloadSubscription;
  ban: (
    where?: BanSubscriptionWhereInput
  ) => BanSubscriptionPayloadSubscription;
  bot: (
    where?: BotSubscriptionWhereInput
  ) => BotSubscriptionPayloadSubscription;
  catalogItem: (
    where?: CatalogItemSubscriptionWhereInput
  ) => CatalogItemSubscriptionPayloadSubscription;
  currencies: (
    where?: CurrenciesSubscriptionWhereInput
  ) => CurrenciesSubscriptionPayloadSubscription;
  room: (
    where?: RoomSubscriptionWhereInput
  ) => RoomSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type BadgeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "description_ASC"
  | "description_DESC";

export type banStatus = "BANNED" | "APPEALING" | "REJECTED";

export type banType = "USER" | "IP" | "MACHINE";

export type BanOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "reason_ASC"
  | "reason_DESC"
  | "status_ASC"
  | "status_DESC"
  | "type_ASC"
  | "type_DESC"
  | "user_ASC"
  | "user_DESC"
  | "ip_ASC"
  | "ip_DESC"
  | "machine_ASC"
  | "machine_DESC"
  | "by_ASC"
  | "by_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BotOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "motto_ASC"
  | "motto_DESC"
  | "inventory_ASC"
  | "inventory_DESC"
  | "owner_ASC"
  | "owner_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "figure_ASC"
  | "figure_DESC"
  | "type_ASC"
  | "type_DESC"
  | "messages_ASC"
  | "messages_DESC"
  | "chatBubble_ASC"
  | "chatBubble_DESC"
  | "chatAuto_ASC"
  | "chatAuto_DESC"
  | "chatRandom_ASC"
  | "chatRandom_DESC"
  | "chatDelay_ASC"
  | "chatDelay_DESC";

export type CatalogItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "page_ASC"
  | "page_DESC"
  | "item_ASC"
  | "item_DESC"
  | "name_ASC"
  | "name_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "limited_ASC"
  | "limited_DESC"
  | "maximum_ASC"
  | "maximum_DESC"
  | "stack_ASC"
  | "stack_DESC"
  | "active_ASC"
  | "active_DESC";

export type CurrenciesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "value_ASC"
  | "value_DESC";

export type RoomOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "likes_ASC"
  | "likes_DESC"
  | "password_ASC"
  | "password_DESC"
  | "type_ASC"
  | "type_DESC"
  | "category_ASC"
  | "category_DESC"
  | "owner_ASC"
  | "owner_DESC"
  | "max_ASC"
  | "max_DESC"
  | "wallpaper_ASC"
  | "wallpaper_DESC"
  | "floor_ASC"
  | "floor_DESC"
  | "landscape_ASC"
  | "landscape_DESC"
  | "wallThickness_ASC"
  | "wallThickness_DESC"
  | "tileThickness_ASC"
  | "tileThickness_DESC"
  | "trading_ASC"
  | "trading_DESC"
  | "effects_ASC"
  | "effects_DESC"
  | "pets_ASC"
  | "pets_DESC"
  | "petsEat_ASC"
  | "petsEat_DESC"
  | "hideWired_ASC"
  | "hideWired_DESC"
  | "staffPicks_ASC"
  | "staffPicks_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "username_ASC"
  | "username_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "pin_ASC"
  | "pin_DESC"
  | "motto_ASC"
  | "motto_DESC"
  | "figure_ASC"
  | "figure_DESC"
  | "rank_ASC"
  | "rank_DESC"
  | "vip_ASC"
  | "vip_DESC"
  | "online_ASC"
  | "online_DESC"
  | "verified_ASC"
  | "verified_DESC"
  | "home_ASC"
  | "home_DESC"
  | "volume_ASC"
  | "volume_DESC"
  | "muted_ASC"
  | "muted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type BadgeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  code?: String;
}>;

export interface BadgeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: BadgeWhereInput[] | BadgeWhereInput;
  OR?: BadgeWhereInput[] | BadgeWhereInput;
  NOT?: BadgeWhereInput[] | BadgeWhereInput;
}

export type BanWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BanWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  reason?: String;
  reason_not?: String;
  reason_in?: String[] | String;
  reason_not_in?: String[] | String;
  reason_lt?: String;
  reason_lte?: String;
  reason_gt?: String;
  reason_gte?: String;
  reason_contains?: String;
  reason_not_contains?: String;
  reason_starts_with?: String;
  reason_not_starts_with?: String;
  reason_ends_with?: String;
  reason_not_ends_with?: String;
  status?: banStatus;
  status_not?: banStatus;
  status_in?: banStatus[] | banStatus;
  status_not_in?: banStatus[] | banStatus;
  type?: banType;
  type_not?: banType;
  type_in?: banType[] | banType;
  type_not_in?: banType[] | banType;
  user?: Int;
  user_not?: Int;
  user_in?: Int[] | Int;
  user_not_in?: Int[] | Int;
  user_lt?: Int;
  user_lte?: Int;
  user_gt?: Int;
  user_gte?: Int;
  ip?: String;
  ip_not?: String;
  ip_in?: String[] | String;
  ip_not_in?: String[] | String;
  ip_lt?: String;
  ip_lte?: String;
  ip_gt?: String;
  ip_gte?: String;
  ip_contains?: String;
  ip_not_contains?: String;
  ip_starts_with?: String;
  ip_not_starts_with?: String;
  ip_ends_with?: String;
  ip_not_ends_with?: String;
  machine?: String;
  machine_not?: String;
  machine_in?: String[] | String;
  machine_not_in?: String[] | String;
  machine_lt?: String;
  machine_lte?: String;
  machine_gt?: String;
  machine_gte?: String;
  machine_contains?: String;
  machine_not_contains?: String;
  machine_starts_with?: String;
  machine_not_starts_with?: String;
  machine_ends_with?: String;
  machine_not_ends_with?: String;
  by?: Int;
  by_not?: Int;
  by_in?: Int[] | Int;
  by_not_in?: Int[] | Int;
  by_lt?: Int;
  by_lte?: Int;
  by_gt?: Int;
  by_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: BanWhereInput[] | BanWhereInput;
  OR?: BanWhereInput[] | BanWhereInput;
  NOT?: BanWhereInput[] | BanWhereInput;
}

export type BotWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BotWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  motto?: String;
  motto_not?: String;
  motto_in?: String[] | String;
  motto_not_in?: String[] | String;
  motto_lt?: String;
  motto_lte?: String;
  motto_gt?: String;
  motto_gte?: String;
  motto_contains?: String;
  motto_not_contains?: String;
  motto_starts_with?: String;
  motto_not_starts_with?: String;
  motto_ends_with?: String;
  motto_not_ends_with?: String;
  inventory?: Boolean;
  inventory_not?: Boolean;
  owner?: Int;
  owner_not?: Int;
  owner_in?: Int[] | Int;
  owner_not_in?: Int[] | Int;
  owner_lt?: Int;
  owner_lte?: Int;
  owner_gt?: Int;
  owner_gte?: Int;
  gender?: Boolean;
  gender_not?: Boolean;
  figure?: String;
  figure_not?: String;
  figure_in?: String[] | String;
  figure_not_in?: String[] | String;
  figure_lt?: String;
  figure_lte?: String;
  figure_gt?: String;
  figure_gte?: String;
  figure_contains?: String;
  figure_not_contains?: String;
  figure_starts_with?: String;
  figure_not_starts_with?: String;
  figure_ends_with?: String;
  figure_not_ends_with?: String;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  messages?: String;
  messages_not?: String;
  messages_in?: String[] | String;
  messages_not_in?: String[] | String;
  messages_lt?: String;
  messages_lte?: String;
  messages_gt?: String;
  messages_gte?: String;
  messages_contains?: String;
  messages_not_contains?: String;
  messages_starts_with?: String;
  messages_not_starts_with?: String;
  messages_ends_with?: String;
  messages_not_ends_with?: String;
  chatBubble?: Int;
  chatBubble_not?: Int;
  chatBubble_in?: Int[] | Int;
  chatBubble_not_in?: Int[] | Int;
  chatBubble_lt?: Int;
  chatBubble_lte?: Int;
  chatBubble_gt?: Int;
  chatBubble_gte?: Int;
  chatAuto?: Int;
  chatAuto_not?: Int;
  chatAuto_in?: Int[] | Int;
  chatAuto_not_in?: Int[] | Int;
  chatAuto_lt?: Int;
  chatAuto_lte?: Int;
  chatAuto_gt?: Int;
  chatAuto_gte?: Int;
  chatRandom?: Boolean;
  chatRandom_not?: Boolean;
  chatDelay?: Int;
  chatDelay_not?: Int;
  chatDelay_in?: Int[] | Int;
  chatDelay_not_in?: Int[] | Int;
  chatDelay_lt?: Int;
  chatDelay_lte?: Int;
  chatDelay_gt?: Int;
  chatDelay_gte?: Int;
  AND?: BotWhereInput[] | BotWhereInput;
  OR?: BotWhereInput[] | BotWhereInput;
  NOT?: BotWhereInput[] | BotWhereInput;
}

export type CatalogItemWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CatalogItemWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  page?: Int;
  page_not?: Int;
  page_in?: Int[] | Int;
  page_not_in?: Int[] | Int;
  page_lt?: Int;
  page_lte?: Int;
  page_gt?: Int;
  page_gte?: Int;
  item?: Int;
  item_not?: Int;
  item_in?: Int[] | Int;
  item_not_in?: Int[] | Int;
  item_lt?: Int;
  item_lte?: Int;
  item_gt?: Int;
  item_gte?: Int;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  price?: CurrenciesWhereInput;
  amount?: Int;
  amount_not?: Int;
  amount_in?: Int[] | Int;
  amount_not_in?: Int[] | Int;
  amount_lt?: Int;
  amount_lte?: Int;
  amount_gt?: Int;
  amount_gte?: Int;
  limited?: Boolean;
  limited_not?: Boolean;
  maximum?: Int;
  maximum_not?: Int;
  maximum_in?: Int[] | Int;
  maximum_not_in?: Int[] | Int;
  maximum_lt?: Int;
  maximum_lte?: Int;
  maximum_gt?: Int;
  maximum_gte?: Int;
  stack?: Boolean;
  stack_not?: Boolean;
  active?: Boolean;
  active_not?: Boolean;
  AND?: CatalogItemWhereInput[] | CatalogItemWhereInput;
  OR?: CatalogItemWhereInput[] | CatalogItemWhereInput;
  NOT?: CatalogItemWhereInput[] | CatalogItemWhereInput;
}

export interface CurrenciesWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  value?: Int;
  value_not?: Int;
  value_in?: Int[] | Int;
  value_not_in?: Int[] | Int;
  value_lt?: Int;
  value_lte?: Int;
  value_gt?: Int;
  value_gte?: Int;
  AND?: CurrenciesWhereInput[] | CurrenciesWhereInput;
  OR?: CurrenciesWhereInput[] | CurrenciesWhereInput;
  NOT?: CurrenciesWhereInput[] | CurrenciesWhereInput;
}

export type CurrenciesWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type RoomWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface RoomWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  likes?: Int;
  likes_not?: Int;
  likes_in?: Int[] | Int;
  likes_not_in?: Int[] | Int;
  likes_lt?: Int;
  likes_lte?: Int;
  likes_gt?: Int;
  likes_gte?: Int;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  type?: Int;
  type_not?: Int;
  type_in?: Int[] | Int;
  type_not_in?: Int[] | Int;
  type_lt?: Int;
  type_lte?: Int;
  type_gt?: Int;
  type_gte?: Int;
  category?: Int;
  category_not?: Int;
  category_in?: Int[] | Int;
  category_not_in?: Int[] | Int;
  category_lt?: Int;
  category_lte?: Int;
  category_gt?: Int;
  category_gte?: Int;
  owner?: Int;
  owner_not?: Int;
  owner_in?: Int[] | Int;
  owner_not_in?: Int[] | Int;
  owner_lt?: Int;
  owner_lte?: Int;
  owner_gt?: Int;
  owner_gte?: Int;
  max?: Int;
  max_not?: Int;
  max_in?: Int[] | Int;
  max_not_in?: Int[] | Int;
  max_lt?: Int;
  max_lte?: Int;
  max_gt?: Int;
  max_gte?: Int;
  wallpaper?: Int;
  wallpaper_not?: Int;
  wallpaper_in?: Int[] | Int;
  wallpaper_not_in?: Int[] | Int;
  wallpaper_lt?: Int;
  wallpaper_lte?: Int;
  wallpaper_gt?: Int;
  wallpaper_gte?: Int;
  floor?: Int;
  floor_not?: Int;
  floor_in?: Int[] | Int;
  floor_not_in?: Int[] | Int;
  floor_lt?: Int;
  floor_lte?: Int;
  floor_gt?: Int;
  floor_gte?: Int;
  landscape?: Int;
  landscape_not?: Int;
  landscape_in?: Int[] | Int;
  landscape_not_in?: Int[] | Int;
  landscape_lt?: Int;
  landscape_lte?: Int;
  landscape_gt?: Int;
  landscape_gte?: Int;
  wallThickness?: Int;
  wallThickness_not?: Int;
  wallThickness_in?: Int[] | Int;
  wallThickness_not_in?: Int[] | Int;
  wallThickness_lt?: Int;
  wallThickness_lte?: Int;
  wallThickness_gt?: Int;
  wallThickness_gte?: Int;
  tileThickness?: Int;
  tileThickness_not?: Int;
  tileThickness_in?: Int[] | Int;
  tileThickness_not_in?: Int[] | Int;
  tileThickness_lt?: Int;
  tileThickness_lte?: Int;
  tileThickness_gt?: Int;
  tileThickness_gte?: Int;
  trading?: Boolean;
  trading_not?: Boolean;
  effects?: Boolean;
  effects_not?: Boolean;
  pets?: Boolean;
  pets_not?: Boolean;
  petsEat?: Boolean;
  petsEat_not?: Boolean;
  hideWired?: Boolean;
  hideWired_not?: Boolean;
  staffPicks?: Boolean;
  staffPicks_not?: Boolean;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: RoomWhereInput[] | RoomWhereInput;
  OR?: RoomWhereInput[] | RoomWhereInput;
  NOT?: RoomWhereInput[] | RoomWhereInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  username?: String;
}>;

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  pin?: Int;
  pin_not?: Int;
  pin_in?: Int[] | Int;
  pin_not_in?: Int[] | Int;
  pin_lt?: Int;
  pin_lte?: Int;
  pin_gt?: Int;
  pin_gte?: Int;
  motto?: String;
  motto_not?: String;
  motto_in?: String[] | String;
  motto_not_in?: String[] | String;
  motto_lt?: String;
  motto_lte?: String;
  motto_gt?: String;
  motto_gte?: String;
  motto_contains?: String;
  motto_not_contains?: String;
  motto_starts_with?: String;
  motto_not_starts_with?: String;
  motto_ends_with?: String;
  motto_not_ends_with?: String;
  figure?: String;
  figure_not?: String;
  figure_in?: String[] | String;
  figure_not_in?: String[] | String;
  figure_lt?: String;
  figure_lte?: String;
  figure_gt?: String;
  figure_gte?: String;
  figure_contains?: String;
  figure_not_contains?: String;
  figure_starts_with?: String;
  figure_not_starts_with?: String;
  figure_ends_with?: String;
  figure_not_ends_with?: String;
  rank?: Int;
  rank_not?: Int;
  rank_in?: Int[] | Int;
  rank_not_in?: Int[] | Int;
  rank_lt?: Int;
  rank_lte?: Int;
  rank_gt?: Int;
  rank_gte?: Int;
  vip?: Int;
  vip_not?: Int;
  vip_in?: Int[] | Int;
  vip_not_in?: Int[] | Int;
  vip_lt?: Int;
  vip_lte?: Int;
  vip_gt?: Int;
  vip_gte?: Int;
  online?: Boolean;
  online_not?: Boolean;
  verified?: Int;
  verified_not?: Int;
  verified_in?: Int[] | Int;
  verified_not_in?: Int[] | Int;
  verified_lt?: Int;
  verified_lte?: Int;
  verified_gt?: Int;
  verified_gte?: Int;
  home?: Int;
  home_not?: Int;
  home_in?: Int[] | Int;
  home_not_in?: Int[] | Int;
  home_lt?: Int;
  home_lte?: Int;
  home_gt?: Int;
  home_gte?: Int;
  volume?: Int;
  volume_not?: Int;
  volume_in?: Int[] | Int;
  volume_not_in?: Int[] | Int;
  volume_lt?: Int;
  volume_lte?: Int;
  volume_gt?: Int;
  volume_gte?: Int;
  muted?: Boolean;
  muted_not?: Boolean;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface BadgeCreateInput {
  id?: ID_Input;
  code: String;
  description?: String;
}

export interface BadgeUpdateInput {
  code?: String;
  description?: String;
}

export interface BadgeUpdateManyMutationInput {
  code?: String;
  description?: String;
}

export interface BanCreateInput {
  id?: ID_Input;
  reason?: String;
  status?: banStatus;
  type?: banType;
  user?: Int;
  ip?: String;
  machine?: String;
  by?: Int;
}

export interface BanUpdateInput {
  reason?: String;
  status?: banStatus;
  type?: banType;
  user?: Int;
  ip?: String;
  machine?: String;
  by?: Int;
}

export interface BanUpdateManyMutationInput {
  reason?: String;
  status?: banStatus;
  type?: banType;
  user?: Int;
  ip?: String;
  machine?: String;
  by?: Int;
}

export interface BotCreateInput {
  id?: ID_Input;
  name?: String;
  motto?: String;
  inventory?: Boolean;
  owner?: Int;
  gender?: Boolean;
  figure?: String;
  type?: String;
  state?: BotCreatestateInput;
  action?: BotCreateactionInput;
  position?: BotCreatepositionInput;
  messages?: String;
  chatBubble?: Int;
  chatAuto?: Int;
  chatRandom?: Boolean;
  chatDelay?: Int;
}

export interface BotCreatestateInput {
  set?: String[] | String;
}

export interface BotCreateactionInput {
  set?: String[] | String;
}

export interface BotCreatepositionInput {
  set?: Int[] | Int;
}

export interface BotUpdateInput {
  name?: String;
  motto?: String;
  inventory?: Boolean;
  owner?: Int;
  gender?: Boolean;
  figure?: String;
  type?: String;
  state?: BotUpdatestateInput;
  action?: BotUpdateactionInput;
  position?: BotUpdatepositionInput;
  messages?: String;
  chatBubble?: Int;
  chatAuto?: Int;
  chatRandom?: Boolean;
  chatDelay?: Int;
}

export interface BotUpdatestateInput {
  set?: String[] | String;
}

export interface BotUpdateactionInput {
  set?: String[] | String;
}

export interface BotUpdatepositionInput {
  set?: Int[] | Int;
}

export interface BotUpdateManyMutationInput {
  name?: String;
  motto?: String;
  inventory?: Boolean;
  owner?: Int;
  gender?: Boolean;
  figure?: String;
  type?: String;
  state?: BotUpdatestateInput;
  action?: BotUpdateactionInput;
  position?: BotUpdatepositionInput;
  messages?: String;
  chatBubble?: Int;
  chatAuto?: Int;
  chatRandom?: Boolean;
  chatDelay?: Int;
}

export interface CatalogItemCreateInput {
  id?: ID_Input;
  page?: Int;
  item?: Int;
  name?: String;
  price?: CurrenciesCreateOneInput;
  amount?: Int;
  limited?: Boolean;
  maximum?: Int;
  stack?: Boolean;
  active?: Boolean;
}

export interface CurrenciesCreateOneInput {
  create?: CurrenciesCreateInput;
  connect?: CurrenciesWhereUniqueInput;
}

export interface CurrenciesCreateInput {
  id?: ID_Input;
  name: String;
  value?: Int;
}

export interface CatalogItemUpdateInput {
  page?: Int;
  item?: Int;
  name?: String;
  price?: CurrenciesUpdateOneInput;
  amount?: Int;
  limited?: Boolean;
  maximum?: Int;
  stack?: Boolean;
  active?: Boolean;
}

export interface CurrenciesUpdateOneInput {
  create?: CurrenciesCreateInput;
  update?: CurrenciesUpdateDataInput;
  upsert?: CurrenciesUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CurrenciesWhereUniqueInput;
}

export interface CurrenciesUpdateDataInput {
  name?: String;
  value?: Int;
}

export interface CurrenciesUpsertNestedInput {
  update: CurrenciesUpdateDataInput;
  create: CurrenciesCreateInput;
}

export interface CatalogItemUpdateManyMutationInput {
  page?: Int;
  item?: Int;
  name?: String;
  amount?: Int;
  limited?: Boolean;
  maximum?: Int;
  stack?: Boolean;
  active?: Boolean;
}

export interface CurrenciesUpdateInput {
  name?: String;
  value?: Int;
}

export interface CurrenciesUpdateManyMutationInput {
  name?: String;
  value?: Int;
}

export interface RoomCreateInput {
  id?: ID_Input;
  name: String;
  description?: String;
  tag?: RoomCreatetagInput;
  likes?: Int;
  password?: String;
  type?: Int;
  category?: Int;
  owner?: Int;
  max?: Int;
  background?: RoomCreatebackgroundInput;
  wallpaper?: Int;
  floor?: Int;
  landscape?: Int;
  wallThickness?: Int;
  tileThickness?: Int;
  trading?: Boolean;
  effects?: Boolean;
  pets?: Boolean;
  petsEat?: Boolean;
  hideWired?: Boolean;
  staffPicks?: Boolean;
}

export interface RoomCreatetagInput {
  set?: String[] | String;
}

export interface RoomCreatebackgroundInput {
  set?: Int[] | Int;
}

export interface RoomUpdateInput {
  name?: String;
  description?: String;
  tag?: RoomUpdatetagInput;
  likes?: Int;
  password?: String;
  type?: Int;
  category?: Int;
  owner?: Int;
  max?: Int;
  background?: RoomUpdatebackgroundInput;
  wallpaper?: Int;
  floor?: Int;
  landscape?: Int;
  wallThickness?: Int;
  tileThickness?: Int;
  trading?: Boolean;
  effects?: Boolean;
  pets?: Boolean;
  petsEat?: Boolean;
  hideWired?: Boolean;
  staffPicks?: Boolean;
}

export interface RoomUpdatetagInput {
  set?: String[] | String;
}

export interface RoomUpdatebackgroundInput {
  set?: Int[] | Int;
}

export interface RoomUpdateManyMutationInput {
  name?: String;
  description?: String;
  tag?: RoomUpdatetagInput;
  likes?: Int;
  password?: String;
  type?: Int;
  category?: Int;
  owner?: Int;
  max?: Int;
  background?: RoomUpdatebackgroundInput;
  wallpaper?: Int;
  floor?: Int;
  landscape?: Int;
  wallThickness?: Int;
  tileThickness?: Int;
  trading?: Boolean;
  effects?: Boolean;
  pets?: Boolean;
  petsEat?: Boolean;
  hideWired?: Boolean;
  staffPicks?: Boolean;
}

export interface UserCreateInput {
  id?: ID_Input;
  username: String;
  email?: String;
  password?: String;
  pin?: Int;
  motto?: String;
  figure?: String;
  rank?: Int;
  vip?: Int;
  online?: Boolean;
  verified?: Int;
  home?: Int;
  volume?: Int;
  muted?: Boolean;
}

export interface UserUpdateInput {
  username?: String;
  email?: String;
  password?: String;
  pin?: Int;
  motto?: String;
  figure?: String;
  rank?: Int;
  vip?: Int;
  online?: Boolean;
  verified?: Int;
  home?: Int;
  volume?: Int;
  muted?: Boolean;
}

export interface UserUpdateManyMutationInput {
  username?: String;
  email?: String;
  password?: String;
  pin?: Int;
  motto?: String;
  figure?: String;
  rank?: Int;
  vip?: Int;
  online?: Boolean;
  verified?: Int;
  home?: Int;
  volume?: Int;
  muted?: Boolean;
}

export interface BadgeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BadgeWhereInput;
  AND?: BadgeSubscriptionWhereInput[] | BadgeSubscriptionWhereInput;
  OR?: BadgeSubscriptionWhereInput[] | BadgeSubscriptionWhereInput;
  NOT?: BadgeSubscriptionWhereInput[] | BadgeSubscriptionWhereInput;
}

export interface BanSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BanWhereInput;
  AND?: BanSubscriptionWhereInput[] | BanSubscriptionWhereInput;
  OR?: BanSubscriptionWhereInput[] | BanSubscriptionWhereInput;
  NOT?: BanSubscriptionWhereInput[] | BanSubscriptionWhereInput;
}

export interface BotSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BotWhereInput;
  AND?: BotSubscriptionWhereInput[] | BotSubscriptionWhereInput;
  OR?: BotSubscriptionWhereInput[] | BotSubscriptionWhereInput;
  NOT?: BotSubscriptionWhereInput[] | BotSubscriptionWhereInput;
}

export interface CatalogItemSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CatalogItemWhereInput;
  AND?: CatalogItemSubscriptionWhereInput[] | CatalogItemSubscriptionWhereInput;
  OR?: CatalogItemSubscriptionWhereInput[] | CatalogItemSubscriptionWhereInput;
  NOT?: CatalogItemSubscriptionWhereInput[] | CatalogItemSubscriptionWhereInput;
}

export interface CurrenciesSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CurrenciesWhereInput;
  AND?: CurrenciesSubscriptionWhereInput[] | CurrenciesSubscriptionWhereInput;
  OR?: CurrenciesSubscriptionWhereInput[] | CurrenciesSubscriptionWhereInput;
  NOT?: CurrenciesSubscriptionWhereInput[] | CurrenciesSubscriptionWhereInput;
}

export interface RoomSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RoomWhereInput;
  AND?: RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput;
  OR?: RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput;
  NOT?: RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Badge {
  id: ID_Output;
  code: String;
  description?: String;
}

export interface BadgePromise extends Promise<Badge>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  description: () => Promise<String>;
}

export interface BadgeSubscription
  extends Promise<AsyncIterator<Badge>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface BadgeConnection {
  pageInfo: PageInfo;
  edges: BadgeEdge[];
}

export interface BadgeConnectionPromise
  extends Promise<BadgeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BadgeEdge>>() => T;
  aggregate: <T = AggregateBadgePromise>() => T;
}

export interface BadgeConnectionSubscription
  extends Promise<AsyncIterator<BadgeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BadgeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBadgeSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BadgeEdge {
  node: Badge;
  cursor: String;
}

export interface BadgeEdgePromise extends Promise<BadgeEdge>, Fragmentable {
  node: <T = BadgePromise>() => T;
  cursor: () => Promise<String>;
}

export interface BadgeEdgeSubscription
  extends Promise<AsyncIterator<BadgeEdge>>,
    Fragmentable {
  node: <T = BadgeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBadge {
  count: Int;
}

export interface AggregateBadgePromise
  extends Promise<AggregateBadge>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBadgeSubscription
  extends Promise<AsyncIterator<AggregateBadge>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Ban {
  id: ID_Output;
  reason?: String;
  status?: banStatus;
  type?: banType;
  user?: Int;
  ip?: String;
  machine?: String;
  by?: Int;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface BanPromise extends Promise<Ban>, Fragmentable {
  id: () => Promise<ID_Output>;
  reason: () => Promise<String>;
  status: () => Promise<banStatus>;
  type: () => Promise<banType>;
  user: () => Promise<Int>;
  ip: () => Promise<String>;
  machine: () => Promise<String>;
  by: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BanSubscription
  extends Promise<AsyncIterator<Ban>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  reason: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<banStatus>>;
  type: () => Promise<AsyncIterator<banType>>;
  user: () => Promise<AsyncIterator<Int>>;
  ip: () => Promise<AsyncIterator<String>>;
  machine: () => Promise<AsyncIterator<String>>;
  by: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BanConnection {
  pageInfo: PageInfo;
  edges: BanEdge[];
}

export interface BanConnectionPromise
  extends Promise<BanConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BanEdge>>() => T;
  aggregate: <T = AggregateBanPromise>() => T;
}

export interface BanConnectionSubscription
  extends Promise<AsyncIterator<BanConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BanEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBanSubscription>() => T;
}

export interface BanEdge {
  node: Ban;
  cursor: String;
}

export interface BanEdgePromise extends Promise<BanEdge>, Fragmentable {
  node: <T = BanPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BanEdgeSubscription
  extends Promise<AsyncIterator<BanEdge>>,
    Fragmentable {
  node: <T = BanSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBan {
  count: Int;
}

export interface AggregateBanPromise
  extends Promise<AggregateBan>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBanSubscription
  extends Promise<AsyncIterator<AggregateBan>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Bot {
  id: ID_Output;
  name?: String;
  motto?: String;
  inventory?: Boolean;
  owner?: Int;
  gender?: Boolean;
  figure?: String;
  type?: String;
  state: String[];
  action: String[];
  position: Int[];
  messages?: String;
  chatBubble?: Int;
  chatAuto?: Int;
  chatRandom?: Boolean;
  chatDelay?: Int;
}

export interface BotPromise extends Promise<Bot>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  motto: () => Promise<String>;
  inventory: () => Promise<Boolean>;
  owner: () => Promise<Int>;
  gender: () => Promise<Boolean>;
  figure: () => Promise<String>;
  type: () => Promise<String>;
  state: () => Promise<String[]>;
  action: () => Promise<String[]>;
  position: () => Promise<Int[]>;
  messages: () => Promise<String>;
  chatBubble: () => Promise<Int>;
  chatAuto: () => Promise<Int>;
  chatRandom: () => Promise<Boolean>;
  chatDelay: () => Promise<Int>;
}

export interface BotSubscription
  extends Promise<AsyncIterator<Bot>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  motto: () => Promise<AsyncIterator<String>>;
  inventory: () => Promise<AsyncIterator<Boolean>>;
  owner: () => Promise<AsyncIterator<Int>>;
  gender: () => Promise<AsyncIterator<Boolean>>;
  figure: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String[]>>;
  action: () => Promise<AsyncIterator<String[]>>;
  position: () => Promise<AsyncIterator<Int[]>>;
  messages: () => Promise<AsyncIterator<String>>;
  chatBubble: () => Promise<AsyncIterator<Int>>;
  chatAuto: () => Promise<AsyncIterator<Int>>;
  chatRandom: () => Promise<AsyncIterator<Boolean>>;
  chatDelay: () => Promise<AsyncIterator<Int>>;
}

export interface BotConnection {
  pageInfo: PageInfo;
  edges: BotEdge[];
}

export interface BotConnectionPromise
  extends Promise<BotConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BotEdge>>() => T;
  aggregate: <T = AggregateBotPromise>() => T;
}

export interface BotConnectionSubscription
  extends Promise<AsyncIterator<BotConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BotEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBotSubscription>() => T;
}

export interface BotEdge {
  node: Bot;
  cursor: String;
}

export interface BotEdgePromise extends Promise<BotEdge>, Fragmentable {
  node: <T = BotPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BotEdgeSubscription
  extends Promise<AsyncIterator<BotEdge>>,
    Fragmentable {
  node: <T = BotSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBot {
  count: Int;
}

export interface AggregateBotPromise
  extends Promise<AggregateBot>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBotSubscription
  extends Promise<AsyncIterator<AggregateBot>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CatalogItem {
  id: ID_Output;
  page?: Int;
  item?: Int;
  name?: String;
  amount?: Int;
  limited?: Boolean;
  maximum?: Int;
  stack?: Boolean;
  active?: Boolean;
}

export interface CatalogItemPromise extends Promise<CatalogItem>, Fragmentable {
  id: () => Promise<ID_Output>;
  page: () => Promise<Int>;
  item: () => Promise<Int>;
  name: () => Promise<String>;
  price: <T = CurrenciesPromise>() => T;
  amount: () => Promise<Int>;
  limited: () => Promise<Boolean>;
  maximum: () => Promise<Int>;
  stack: () => Promise<Boolean>;
  active: () => Promise<Boolean>;
}

export interface CatalogItemSubscription
  extends Promise<AsyncIterator<CatalogItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  page: () => Promise<AsyncIterator<Int>>;
  item: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  price: <T = CurrenciesSubscription>() => T;
  amount: () => Promise<AsyncIterator<Int>>;
  limited: () => Promise<AsyncIterator<Boolean>>;
  maximum: () => Promise<AsyncIterator<Int>>;
  stack: () => Promise<AsyncIterator<Boolean>>;
  active: () => Promise<AsyncIterator<Boolean>>;
}

export interface Currencies {
  id: ID_Output;
  name: String;
  value?: Int;
}

export interface CurrenciesPromise extends Promise<Currencies>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  value: () => Promise<Int>;
}

export interface CurrenciesSubscription
  extends Promise<AsyncIterator<Currencies>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<Int>>;
}

export interface CatalogItemConnection {
  pageInfo: PageInfo;
  edges: CatalogItemEdge[];
}

export interface CatalogItemConnectionPromise
  extends Promise<CatalogItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CatalogItemEdge>>() => T;
  aggregate: <T = AggregateCatalogItemPromise>() => T;
}

export interface CatalogItemConnectionSubscription
  extends Promise<AsyncIterator<CatalogItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CatalogItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCatalogItemSubscription>() => T;
}

export interface CatalogItemEdge {
  node: CatalogItem;
  cursor: String;
}

export interface CatalogItemEdgePromise
  extends Promise<CatalogItemEdge>,
    Fragmentable {
  node: <T = CatalogItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CatalogItemEdgeSubscription
  extends Promise<AsyncIterator<CatalogItemEdge>>,
    Fragmentable {
  node: <T = CatalogItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCatalogItem {
  count: Int;
}

export interface AggregateCatalogItemPromise
  extends Promise<AggregateCatalogItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCatalogItemSubscription
  extends Promise<AsyncIterator<AggregateCatalogItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CurrenciesConnection {
  pageInfo: PageInfo;
  edges: CurrenciesEdge[];
}

export interface CurrenciesConnectionPromise
  extends Promise<CurrenciesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CurrenciesEdge>>() => T;
  aggregate: <T = AggregateCurrenciesPromise>() => T;
}

export interface CurrenciesConnectionSubscription
  extends Promise<AsyncIterator<CurrenciesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CurrenciesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCurrenciesSubscription>() => T;
}

export interface CurrenciesEdge {
  node: Currencies;
  cursor: String;
}

export interface CurrenciesEdgePromise
  extends Promise<CurrenciesEdge>,
    Fragmentable {
  node: <T = CurrenciesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CurrenciesEdgeSubscription
  extends Promise<AsyncIterator<CurrenciesEdge>>,
    Fragmentable {
  node: <T = CurrenciesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCurrencies {
  count: Int;
}

export interface AggregateCurrenciesPromise
  extends Promise<AggregateCurrencies>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCurrenciesSubscription
  extends Promise<AsyncIterator<AggregateCurrencies>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Room {
  id: ID_Output;
  name: String;
  description?: String;
  tag: String[];
  likes?: Int;
  password?: String;
  type?: Int;
  category?: Int;
  owner?: Int;
  max?: Int;
  background: Int[];
  wallpaper?: Int;
  floor?: Int;
  landscape?: Int;
  wallThickness?: Int;
  tileThickness?: Int;
  trading?: Boolean;
  effects?: Boolean;
  pets?: Boolean;
  petsEat?: Boolean;
  hideWired?: Boolean;
  staffPicks?: Boolean;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface RoomPromise extends Promise<Room>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  tag: () => Promise<String[]>;
  likes: () => Promise<Int>;
  password: () => Promise<String>;
  type: () => Promise<Int>;
  category: () => Promise<Int>;
  owner: () => Promise<Int>;
  max: () => Promise<Int>;
  background: () => Promise<Int[]>;
  wallpaper: () => Promise<Int>;
  floor: () => Promise<Int>;
  landscape: () => Promise<Int>;
  wallThickness: () => Promise<Int>;
  tileThickness: () => Promise<Int>;
  trading: () => Promise<Boolean>;
  effects: () => Promise<Boolean>;
  pets: () => Promise<Boolean>;
  petsEat: () => Promise<Boolean>;
  hideWired: () => Promise<Boolean>;
  staffPicks: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RoomSubscription
  extends Promise<AsyncIterator<Room>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  tag: () => Promise<AsyncIterator<String[]>>;
  likes: () => Promise<AsyncIterator<Int>>;
  password: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<Int>>;
  category: () => Promise<AsyncIterator<Int>>;
  owner: () => Promise<AsyncIterator<Int>>;
  max: () => Promise<AsyncIterator<Int>>;
  background: () => Promise<AsyncIterator<Int[]>>;
  wallpaper: () => Promise<AsyncIterator<Int>>;
  floor: () => Promise<AsyncIterator<Int>>;
  landscape: () => Promise<AsyncIterator<Int>>;
  wallThickness: () => Promise<AsyncIterator<Int>>;
  tileThickness: () => Promise<AsyncIterator<Int>>;
  trading: () => Promise<AsyncIterator<Boolean>>;
  effects: () => Promise<AsyncIterator<Boolean>>;
  pets: () => Promise<AsyncIterator<Boolean>>;
  petsEat: () => Promise<AsyncIterator<Boolean>>;
  hideWired: () => Promise<AsyncIterator<Boolean>>;
  staffPicks: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RoomConnection {
  pageInfo: PageInfo;
  edges: RoomEdge[];
}

export interface RoomConnectionPromise
  extends Promise<RoomConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RoomEdge>>() => T;
  aggregate: <T = AggregateRoomPromise>() => T;
}

export interface RoomConnectionSubscription
  extends Promise<AsyncIterator<RoomConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RoomEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRoomSubscription>() => T;
}

export interface RoomEdge {
  node: Room;
  cursor: String;
}

export interface RoomEdgePromise extends Promise<RoomEdge>, Fragmentable {
  node: <T = RoomPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RoomEdgeSubscription
  extends Promise<AsyncIterator<RoomEdge>>,
    Fragmentable {
  node: <T = RoomSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRoom {
  count: Int;
}

export interface AggregateRoomPromise
  extends Promise<AggregateRoom>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRoomSubscription
  extends Promise<AsyncIterator<AggregateRoom>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  username: String;
  email?: String;
  password?: String;
  pin?: Int;
  motto?: String;
  figure?: String;
  rank?: Int;
  vip?: Int;
  online?: Boolean;
  verified?: Int;
  home?: Int;
  volume?: Int;
  muted?: Boolean;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  pin: () => Promise<Int>;
  motto: () => Promise<String>;
  figure: () => Promise<String>;
  rank: () => Promise<Int>;
  vip: () => Promise<Int>;
  online: () => Promise<Boolean>;
  verified: () => Promise<Int>;
  home: () => Promise<Int>;
  volume: () => Promise<Int>;
  muted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  pin: () => Promise<AsyncIterator<Int>>;
  motto: () => Promise<AsyncIterator<String>>;
  figure: () => Promise<AsyncIterator<String>>;
  rank: () => Promise<AsyncIterator<Int>>;
  vip: () => Promise<AsyncIterator<Int>>;
  online: () => Promise<AsyncIterator<Boolean>>;
  verified: () => Promise<AsyncIterator<Int>>;
  home: () => Promise<AsyncIterator<Int>>;
  volume: () => Promise<AsyncIterator<Int>>;
  muted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface BadgeSubscriptionPayload {
  mutation: MutationType;
  node: Badge;
  updatedFields: String[];
  previousValues: BadgePreviousValues;
}

export interface BadgeSubscriptionPayloadPromise
  extends Promise<BadgeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BadgePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BadgePreviousValuesPromise>() => T;
}

export interface BadgeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BadgeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BadgeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BadgePreviousValuesSubscription>() => T;
}

export interface BadgePreviousValues {
  id: ID_Output;
  code: String;
  description?: String;
}

export interface BadgePreviousValuesPromise
  extends Promise<BadgePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  description: () => Promise<String>;
}

export interface BadgePreviousValuesSubscription
  extends Promise<AsyncIterator<BadgePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface BanSubscriptionPayload {
  mutation: MutationType;
  node: Ban;
  updatedFields: String[];
  previousValues: BanPreviousValues;
}

export interface BanSubscriptionPayloadPromise
  extends Promise<BanSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BanPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BanPreviousValuesPromise>() => T;
}

export interface BanSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BanSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BanSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BanPreviousValuesSubscription>() => T;
}

export interface BanPreviousValues {
  id: ID_Output;
  reason?: String;
  status?: banStatus;
  type?: banType;
  user?: Int;
  ip?: String;
  machine?: String;
  by?: Int;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface BanPreviousValuesPromise
  extends Promise<BanPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  reason: () => Promise<String>;
  status: () => Promise<banStatus>;
  type: () => Promise<banType>;
  user: () => Promise<Int>;
  ip: () => Promise<String>;
  machine: () => Promise<String>;
  by: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BanPreviousValuesSubscription
  extends Promise<AsyncIterator<BanPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  reason: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<banStatus>>;
  type: () => Promise<AsyncIterator<banType>>;
  user: () => Promise<AsyncIterator<Int>>;
  ip: () => Promise<AsyncIterator<String>>;
  machine: () => Promise<AsyncIterator<String>>;
  by: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BotSubscriptionPayload {
  mutation: MutationType;
  node: Bot;
  updatedFields: String[];
  previousValues: BotPreviousValues;
}

export interface BotSubscriptionPayloadPromise
  extends Promise<BotSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BotPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BotPreviousValuesPromise>() => T;
}

export interface BotSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BotSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BotSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BotPreviousValuesSubscription>() => T;
}

export interface BotPreviousValues {
  id: ID_Output;
  name?: String;
  motto?: String;
  inventory?: Boolean;
  owner?: Int;
  gender?: Boolean;
  figure?: String;
  type?: String;
  state: String[];
  action: String[];
  position: Int[];
  messages?: String;
  chatBubble?: Int;
  chatAuto?: Int;
  chatRandom?: Boolean;
  chatDelay?: Int;
}

export interface BotPreviousValuesPromise
  extends Promise<BotPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  motto: () => Promise<String>;
  inventory: () => Promise<Boolean>;
  owner: () => Promise<Int>;
  gender: () => Promise<Boolean>;
  figure: () => Promise<String>;
  type: () => Promise<String>;
  state: () => Promise<String[]>;
  action: () => Promise<String[]>;
  position: () => Promise<Int[]>;
  messages: () => Promise<String>;
  chatBubble: () => Promise<Int>;
  chatAuto: () => Promise<Int>;
  chatRandom: () => Promise<Boolean>;
  chatDelay: () => Promise<Int>;
}

export interface BotPreviousValuesSubscription
  extends Promise<AsyncIterator<BotPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  motto: () => Promise<AsyncIterator<String>>;
  inventory: () => Promise<AsyncIterator<Boolean>>;
  owner: () => Promise<AsyncIterator<Int>>;
  gender: () => Promise<AsyncIterator<Boolean>>;
  figure: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String[]>>;
  action: () => Promise<AsyncIterator<String[]>>;
  position: () => Promise<AsyncIterator<Int[]>>;
  messages: () => Promise<AsyncIterator<String>>;
  chatBubble: () => Promise<AsyncIterator<Int>>;
  chatAuto: () => Promise<AsyncIterator<Int>>;
  chatRandom: () => Promise<AsyncIterator<Boolean>>;
  chatDelay: () => Promise<AsyncIterator<Int>>;
}

export interface CatalogItemSubscriptionPayload {
  mutation: MutationType;
  node: CatalogItem;
  updatedFields: String[];
  previousValues: CatalogItemPreviousValues;
}

export interface CatalogItemSubscriptionPayloadPromise
  extends Promise<CatalogItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CatalogItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CatalogItemPreviousValuesPromise>() => T;
}

export interface CatalogItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CatalogItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CatalogItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CatalogItemPreviousValuesSubscription>() => T;
}

export interface CatalogItemPreviousValues {
  id: ID_Output;
  page?: Int;
  item?: Int;
  name?: String;
  amount?: Int;
  limited?: Boolean;
  maximum?: Int;
  stack?: Boolean;
  active?: Boolean;
}

export interface CatalogItemPreviousValuesPromise
  extends Promise<CatalogItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  page: () => Promise<Int>;
  item: () => Promise<Int>;
  name: () => Promise<String>;
  amount: () => Promise<Int>;
  limited: () => Promise<Boolean>;
  maximum: () => Promise<Int>;
  stack: () => Promise<Boolean>;
  active: () => Promise<Boolean>;
}

export interface CatalogItemPreviousValuesSubscription
  extends Promise<AsyncIterator<CatalogItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  page: () => Promise<AsyncIterator<Int>>;
  item: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Int>>;
  limited: () => Promise<AsyncIterator<Boolean>>;
  maximum: () => Promise<AsyncIterator<Int>>;
  stack: () => Promise<AsyncIterator<Boolean>>;
  active: () => Promise<AsyncIterator<Boolean>>;
}

export interface CurrenciesSubscriptionPayload {
  mutation: MutationType;
  node: Currencies;
  updatedFields: String[];
  previousValues: CurrenciesPreviousValues;
}

export interface CurrenciesSubscriptionPayloadPromise
  extends Promise<CurrenciesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CurrenciesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CurrenciesPreviousValuesPromise>() => T;
}

export interface CurrenciesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CurrenciesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CurrenciesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CurrenciesPreviousValuesSubscription>() => T;
}

export interface CurrenciesPreviousValues {
  id: ID_Output;
  name: String;
  value?: Int;
}

export interface CurrenciesPreviousValuesPromise
  extends Promise<CurrenciesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  value: () => Promise<Int>;
}

export interface CurrenciesPreviousValuesSubscription
  extends Promise<AsyncIterator<CurrenciesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<Int>>;
}

export interface RoomSubscriptionPayload {
  mutation: MutationType;
  node: Room;
  updatedFields: String[];
  previousValues: RoomPreviousValues;
}

export interface RoomSubscriptionPayloadPromise
  extends Promise<RoomSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RoomPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RoomPreviousValuesPromise>() => T;
}

export interface RoomSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RoomSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RoomSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RoomPreviousValuesSubscription>() => T;
}

export interface RoomPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  tag: String[];
  likes?: Int;
  password?: String;
  type?: Int;
  category?: Int;
  owner?: Int;
  max?: Int;
  background: Int[];
  wallpaper?: Int;
  floor?: Int;
  landscape?: Int;
  wallThickness?: Int;
  tileThickness?: Int;
  trading?: Boolean;
  effects?: Boolean;
  pets?: Boolean;
  petsEat?: Boolean;
  hideWired?: Boolean;
  staffPicks?: Boolean;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface RoomPreviousValuesPromise
  extends Promise<RoomPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  tag: () => Promise<String[]>;
  likes: () => Promise<Int>;
  password: () => Promise<String>;
  type: () => Promise<Int>;
  category: () => Promise<Int>;
  owner: () => Promise<Int>;
  max: () => Promise<Int>;
  background: () => Promise<Int[]>;
  wallpaper: () => Promise<Int>;
  floor: () => Promise<Int>;
  landscape: () => Promise<Int>;
  wallThickness: () => Promise<Int>;
  tileThickness: () => Promise<Int>;
  trading: () => Promise<Boolean>;
  effects: () => Promise<Boolean>;
  pets: () => Promise<Boolean>;
  petsEat: () => Promise<Boolean>;
  hideWired: () => Promise<Boolean>;
  staffPicks: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RoomPreviousValuesSubscription
  extends Promise<AsyncIterator<RoomPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  tag: () => Promise<AsyncIterator<String[]>>;
  likes: () => Promise<AsyncIterator<Int>>;
  password: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<Int>>;
  category: () => Promise<AsyncIterator<Int>>;
  owner: () => Promise<AsyncIterator<Int>>;
  max: () => Promise<AsyncIterator<Int>>;
  background: () => Promise<AsyncIterator<Int[]>>;
  wallpaper: () => Promise<AsyncIterator<Int>>;
  floor: () => Promise<AsyncIterator<Int>>;
  landscape: () => Promise<AsyncIterator<Int>>;
  wallThickness: () => Promise<AsyncIterator<Int>>;
  tileThickness: () => Promise<AsyncIterator<Int>>;
  trading: () => Promise<AsyncIterator<Boolean>>;
  effects: () => Promise<AsyncIterator<Boolean>>;
  pets: () => Promise<AsyncIterator<Boolean>>;
  petsEat: () => Promise<AsyncIterator<Boolean>>;
  hideWired: () => Promise<AsyncIterator<Boolean>>;
  staffPicks: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  username: String;
  email?: String;
  password?: String;
  pin?: Int;
  motto?: String;
  figure?: String;
  rank?: Int;
  vip?: Int;
  online?: Boolean;
  verified?: Int;
  home?: Int;
  volume?: Int;
  muted?: Boolean;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  pin: () => Promise<Int>;
  motto: () => Promise<String>;
  figure: () => Promise<String>;
  rank: () => Promise<Int>;
  vip: () => Promise<Int>;
  online: () => Promise<Boolean>;
  verified: () => Promise<Int>;
  home: () => Promise<Int>;
  volume: () => Promise<Int>;
  muted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  pin: () => Promise<AsyncIterator<Int>>;
  motto: () => Promise<AsyncIterator<String>>;
  figure: () => Promise<AsyncIterator<String>>;
  rank: () => Promise<AsyncIterator<Int>>;
  vip: () => Promise<AsyncIterator<Int>>;
  online: () => Promise<AsyncIterator<Boolean>>;
  verified: () => Promise<AsyncIterator<Int>>;
  home: () => Promise<AsyncIterator<Int>>;
  volume: () => Promise<AsyncIterator<Int>>;
  muted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "banType",
    embedded: false
  },
  {
    name: "banStatus",
    embedded: false
  },
  {
    name: "Ban",
    embedded: false
  },
  {
    name: "Badge",
    embedded: false
  },
  {
    name: "Bot",
    embedded: false
  },
  {
    name: "CatalogItem",
    embedded: false
  },
  {
    name: "Currencies",
    embedded: false
  },
  {
    name: "Room",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
