// Code generated by Prisma (prisma@1.32.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  badge: (where?: BadgeWhereInput) => Promise<boolean>;
  ban: (where?: BanWhereInput) => Promise<boolean>;
  bot: (where?: BotWhereInput) => Promise<boolean>;
  catalogItem: (where?: CatalogItemWhereInput) => Promise<boolean>;
  catalogPage: (where?: CatalogPageWhereInput) => Promise<boolean>;
  item: (where?: ItemWhereInput) => Promise<boolean>;
  room: (where?: RoomWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  badge: (where: BadgeWhereUniqueInput) => BadgeNullablePromise;
  badges: (args?: {
    where?: BadgeWhereInput;
    orderBy?: BadgeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Badge>;
  badgesConnection: (args?: {
    where?: BadgeWhereInput;
    orderBy?: BadgeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BadgeConnectionPromise;
  ban: (where: BanWhereUniqueInput) => BanNullablePromise;
  bans: (args?: {
    where?: BanWhereInput;
    orderBy?: BanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Ban>;
  bansConnection: (args?: {
    where?: BanWhereInput;
    orderBy?: BanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BanConnectionPromise;
  bot: (where: BotWhereUniqueInput) => BotNullablePromise;
  bots: (args?: {
    where?: BotWhereInput;
    orderBy?: BotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Bot>;
  botsConnection: (args?: {
    where?: BotWhereInput;
    orderBy?: BotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BotConnectionPromise;
  catalogItem: (
    where: CatalogItemWhereUniqueInput
  ) => CatalogItemNullablePromise;
  catalogItems: (args?: {
    where?: CatalogItemWhereInput;
    orderBy?: CatalogItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CatalogItem>;
  catalogItemsConnection: (args?: {
    where?: CatalogItemWhereInput;
    orderBy?: CatalogItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CatalogItemConnectionPromise;
  catalogPage: (
    where: CatalogPageWhereUniqueInput
  ) => CatalogPageNullablePromise;
  catalogPages: (args?: {
    where?: CatalogPageWhereInput;
    orderBy?: CatalogPageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CatalogPage>;
  catalogPagesConnection: (args?: {
    where?: CatalogPageWhereInput;
    orderBy?: CatalogPageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CatalogPageConnectionPromise;
  item: (where: ItemWhereUniqueInput) => ItemNullablePromise;
  items: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Item>;
  itemsConnection: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ItemConnectionPromise;
  room: (where: RoomWhereUniqueInput) => RoomNullablePromise;
  rooms: (args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Room>;
  roomsConnection: (args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RoomConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBadge: (data: BadgeCreateInput) => BadgePromise;
  updateBadge: (args: {
    data: BadgeUpdateInput;
    where: BadgeWhereUniqueInput;
  }) => BadgePromise;
  updateManyBadges: (args: {
    data: BadgeUpdateManyMutationInput;
    where?: BadgeWhereInput;
  }) => BatchPayloadPromise;
  upsertBadge: (args: {
    where: BadgeWhereUniqueInput;
    create: BadgeCreateInput;
    update: BadgeUpdateInput;
  }) => BadgePromise;
  deleteBadge: (where: BadgeWhereUniqueInput) => BadgePromise;
  deleteManyBadges: (where?: BadgeWhereInput) => BatchPayloadPromise;
  createBan: (data: BanCreateInput) => BanPromise;
  updateBan: (args: {
    data: BanUpdateInput;
    where: BanWhereUniqueInput;
  }) => BanPromise;
  updateManyBans: (args: {
    data: BanUpdateManyMutationInput;
    where?: BanWhereInput;
  }) => BatchPayloadPromise;
  upsertBan: (args: {
    where: BanWhereUniqueInput;
    create: BanCreateInput;
    update: BanUpdateInput;
  }) => BanPromise;
  deleteBan: (where: BanWhereUniqueInput) => BanPromise;
  deleteManyBans: (where?: BanWhereInput) => BatchPayloadPromise;
  createBot: (data: BotCreateInput) => BotPromise;
  updateBot: (args: {
    data: BotUpdateInput;
    where: BotWhereUniqueInput;
  }) => BotPromise;
  updateManyBots: (args: {
    data: BotUpdateManyMutationInput;
    where?: BotWhereInput;
  }) => BatchPayloadPromise;
  upsertBot: (args: {
    where: BotWhereUniqueInput;
    create: BotCreateInput;
    update: BotUpdateInput;
  }) => BotPromise;
  deleteBot: (where: BotWhereUniqueInput) => BotPromise;
  deleteManyBots: (where?: BotWhereInput) => BatchPayloadPromise;
  createCatalogItem: (data: CatalogItemCreateInput) => CatalogItemPromise;
  updateCatalogItem: (args: {
    data: CatalogItemUpdateInput;
    where: CatalogItemWhereUniqueInput;
  }) => CatalogItemPromise;
  updateManyCatalogItems: (args: {
    data: CatalogItemUpdateManyMutationInput;
    where?: CatalogItemWhereInput;
  }) => BatchPayloadPromise;
  upsertCatalogItem: (args: {
    where: CatalogItemWhereUniqueInput;
    create: CatalogItemCreateInput;
    update: CatalogItemUpdateInput;
  }) => CatalogItemPromise;
  deleteCatalogItem: (where: CatalogItemWhereUniqueInput) => CatalogItemPromise;
  deleteManyCatalogItems: (
    where?: CatalogItemWhereInput
  ) => BatchPayloadPromise;
  createCatalogPage: (data: CatalogPageCreateInput) => CatalogPagePromise;
  updateCatalogPage: (args: {
    data: CatalogPageUpdateInput;
    where: CatalogPageWhereUniqueInput;
  }) => CatalogPagePromise;
  updateManyCatalogPages: (args: {
    data: CatalogPageUpdateManyMutationInput;
    where?: CatalogPageWhereInput;
  }) => BatchPayloadPromise;
  upsertCatalogPage: (args: {
    where: CatalogPageWhereUniqueInput;
    create: CatalogPageCreateInput;
    update: CatalogPageUpdateInput;
  }) => CatalogPagePromise;
  deleteCatalogPage: (where: CatalogPageWhereUniqueInput) => CatalogPagePromise;
  deleteManyCatalogPages: (
    where?: CatalogPageWhereInput
  ) => BatchPayloadPromise;
  createItem: (data: ItemCreateInput) => ItemPromise;
  updateItem: (args: {
    data: ItemUpdateInput;
    where: ItemWhereUniqueInput;
  }) => ItemPromise;
  updateManyItems: (args: {
    data: ItemUpdateManyMutationInput;
    where?: ItemWhereInput;
  }) => BatchPayloadPromise;
  upsertItem: (args: {
    where: ItemWhereUniqueInput;
    create: ItemCreateInput;
    update: ItemUpdateInput;
  }) => ItemPromise;
  deleteItem: (where: ItemWhereUniqueInput) => ItemPromise;
  deleteManyItems: (where?: ItemWhereInput) => BatchPayloadPromise;
  createRoom: (data: RoomCreateInput) => RoomPromise;
  updateRoom: (args: {
    data: RoomUpdateInput;
    where: RoomWhereUniqueInput;
  }) => RoomPromise;
  updateManyRooms: (args: {
    data: RoomUpdateManyMutationInput;
    where?: RoomWhereInput;
  }) => BatchPayloadPromise;
  upsertRoom: (args: {
    where: RoomWhereUniqueInput;
    create: RoomCreateInput;
    update: RoomUpdateInput;
  }) => RoomPromise;
  deleteRoom: (where: RoomWhereUniqueInput) => RoomPromise;
  deleteManyRooms: (where?: RoomWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  badge: (
    where?: BadgeSubscriptionWhereInput
  ) => BadgeSubscriptionPayloadSubscription;
  ban: (
    where?: BanSubscriptionWhereInput
  ) => BanSubscriptionPayloadSubscription;
  bot: (
    where?: BotSubscriptionWhereInput
  ) => BotSubscriptionPayloadSubscription;
  catalogItem: (
    where?: CatalogItemSubscriptionWhereInput
  ) => CatalogItemSubscriptionPayloadSubscription;
  catalogPage: (
    where?: CatalogPageSubscriptionWhereInput
  ) => CatalogPageSubscriptionPayloadSubscription;
  item: (
    where?: ItemSubscriptionWhereInput
  ) => ItemSubscriptionPayloadSubscription;
  room: (
    where?: RoomSubscriptionWhereInput
  ) => RoomSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type BadgeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "description_ASC"
  | "description_DESC";

export type banStatus = "BANNED" | "APPEALING" | "REJECTED";

export type banType = "USER" | "IP" | "MACHINE";

export type BanOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "reason_ASC"
  | "reason_DESC"
  | "status_ASC"
  | "status_DESC"
  | "type_ASC"
  | "type_DESC"
  | "user_ASC"
  | "user_DESC"
  | "ip_ASC"
  | "ip_DESC"
  | "machine_ASC"
  | "machine_DESC"
  | "by_ASC"
  | "by_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BotOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "motto_ASC"
  | "motto_DESC"
  | "inventory_ASC"
  | "inventory_DESC"
  | "owner_ASC"
  | "owner_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "figure_ASC"
  | "figure_DESC"
  | "type_ASC"
  | "type_DESC"
  | "messages_ASC"
  | "messages_DESC"
  | "chatBubble_ASC"
  | "chatBubble_DESC"
  | "chatAuto_ASC"
  | "chatAuto_DESC"
  | "chatRandom_ASC"
  | "chatRandom_DESC"
  | "chatDelay_ASC"
  | "chatDelay_DESC";

export type CatalogItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "page_ASC"
  | "page_DESC"
  | "item_ASC"
  | "item_DESC"
  | "name_ASC"
  | "name_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "limited_ASC"
  | "limited_DESC"
  | "maximum_ASC"
  | "maximum_DESC"
  | "stack_ASC"
  | "stack_DESC"
  | "active_ASC"
  | "active_DESC";

export type CatalogPageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "parent_ASC"
  | "parent_DESC"
  | "type_ASC"
  | "type_DESC"
  | "order_ASC"
  | "order_DESC"
  | "name_ASC"
  | "name_DESC"
  | "caption_ASC"
  | "caption_DESC"
  | "description_ASC"
  | "description_DESC"
  | "icon_ASC"
  | "icon_DESC"
  | "visible_ASC"
  | "visible_DESC"
  | "enabled_ASC"
  | "enabled_DESC"
  | "rank_ASC"
  | "rank_DESC"
  | "club_ASC"
  | "club_DESC"
  | "vip_ASC"
  | "vip_DESC"
  | "body_ASC"
  | "body_DESC";

export type roomType = "PUBLIC" | "LOCKED" | "PASSWORD" | "HIDDEN";

export type ItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "owner_ASC"
  | "owner_DESC"
  | "furniture_ASC"
  | "furniture_DESC"
  | "type_ASC"
  | "type_DESC"
  | "x_ASC"
  | "x_DESC"
  | "y_ASC"
  | "y_DESC"
  | "z_ASC"
  | "z_DESC"
  | "rotation_ASC"
  | "rotation_DESC"
  | "inventory_ASC"
  | "inventory_DESC";

export type RoomOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "type_ASC"
  | "type_DESC"
  | "category_ASC"
  | "category_DESC"
  | "owner_ASC"
  | "owner_DESC"
  | "map_ASC"
  | "map_DESC"
  | "floorThickness_ASC"
  | "floorThickness_DESC"
  | "wallThickness_ASC"
  | "wallThickness_DESC"
  | "wallHeight_ASC"
  | "wallHeight_DESC"
  | "hideWalls_ASC"
  | "hideWalls_DESC"
  | "hideWired_ASC"
  | "hideWired_DESC"
  | "maxUsers_ASC"
  | "maxUsers_DESC"
  | "allowPets_ASC"
  | "allowPets_DESC"
  | "allowPetsEating_ASC"
  | "allowPetsEating_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "username_ASC"
  | "username_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "pin_ASC"
  | "pin_DESC"
  | "motto_ASC"
  | "motto_DESC"
  | "figure_ASC"
  | "figure_DESC"
  | "rank_ASC"
  | "rank_DESC"
  | "vip_ASC"
  | "vip_DESC"
  | "online_ASC"
  | "online_DESC"
  | "verified_ASC"
  | "verified_DESC"
  | "home_ASC"
  | "home_DESC"
  | "volume_ASC"
  | "volume_DESC"
  | "muted_ASC"
  | "muted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type BadgeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  code?: Maybe<String>;
}>;

export interface BadgeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<BadgeWhereInput[] | BadgeWhereInput>;
  OR?: Maybe<BadgeWhereInput[] | BadgeWhereInput>;
  NOT?: Maybe<BadgeWhereInput[] | BadgeWhereInput>;
}

export type BanWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BanWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  reason?: Maybe<String>;
  reason_not?: Maybe<String>;
  reason_in?: Maybe<String[] | String>;
  reason_not_in?: Maybe<String[] | String>;
  reason_lt?: Maybe<String>;
  reason_lte?: Maybe<String>;
  reason_gt?: Maybe<String>;
  reason_gte?: Maybe<String>;
  reason_contains?: Maybe<String>;
  reason_not_contains?: Maybe<String>;
  reason_starts_with?: Maybe<String>;
  reason_not_starts_with?: Maybe<String>;
  reason_ends_with?: Maybe<String>;
  reason_not_ends_with?: Maybe<String>;
  status?: Maybe<banStatus>;
  status_not?: Maybe<banStatus>;
  status_in?: Maybe<banStatus[] | banStatus>;
  status_not_in?: Maybe<banStatus[] | banStatus>;
  type?: Maybe<banType>;
  type_not?: Maybe<banType>;
  type_in?: Maybe<banType[] | banType>;
  type_not_in?: Maybe<banType[] | banType>;
  user?: Maybe<Int>;
  user_not?: Maybe<Int>;
  user_in?: Maybe<Int[] | Int>;
  user_not_in?: Maybe<Int[] | Int>;
  user_lt?: Maybe<Int>;
  user_lte?: Maybe<Int>;
  user_gt?: Maybe<Int>;
  user_gte?: Maybe<Int>;
  ip?: Maybe<String>;
  ip_not?: Maybe<String>;
  ip_in?: Maybe<String[] | String>;
  ip_not_in?: Maybe<String[] | String>;
  ip_lt?: Maybe<String>;
  ip_lte?: Maybe<String>;
  ip_gt?: Maybe<String>;
  ip_gte?: Maybe<String>;
  ip_contains?: Maybe<String>;
  ip_not_contains?: Maybe<String>;
  ip_starts_with?: Maybe<String>;
  ip_not_starts_with?: Maybe<String>;
  ip_ends_with?: Maybe<String>;
  ip_not_ends_with?: Maybe<String>;
  machine?: Maybe<String>;
  machine_not?: Maybe<String>;
  machine_in?: Maybe<String[] | String>;
  machine_not_in?: Maybe<String[] | String>;
  machine_lt?: Maybe<String>;
  machine_lte?: Maybe<String>;
  machine_gt?: Maybe<String>;
  machine_gte?: Maybe<String>;
  machine_contains?: Maybe<String>;
  machine_not_contains?: Maybe<String>;
  machine_starts_with?: Maybe<String>;
  machine_not_starts_with?: Maybe<String>;
  machine_ends_with?: Maybe<String>;
  machine_not_ends_with?: Maybe<String>;
  by?: Maybe<Int>;
  by_not?: Maybe<Int>;
  by_in?: Maybe<Int[] | Int>;
  by_not_in?: Maybe<Int[] | Int>;
  by_lt?: Maybe<Int>;
  by_lte?: Maybe<Int>;
  by_gt?: Maybe<Int>;
  by_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BanWhereInput[] | BanWhereInput>;
  OR?: Maybe<BanWhereInput[] | BanWhereInput>;
  NOT?: Maybe<BanWhereInput[] | BanWhereInput>;
}

export type BotWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BotWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  motto?: Maybe<String>;
  motto_not?: Maybe<String>;
  motto_in?: Maybe<String[] | String>;
  motto_not_in?: Maybe<String[] | String>;
  motto_lt?: Maybe<String>;
  motto_lte?: Maybe<String>;
  motto_gt?: Maybe<String>;
  motto_gte?: Maybe<String>;
  motto_contains?: Maybe<String>;
  motto_not_contains?: Maybe<String>;
  motto_starts_with?: Maybe<String>;
  motto_not_starts_with?: Maybe<String>;
  motto_ends_with?: Maybe<String>;
  motto_not_ends_with?: Maybe<String>;
  inventory?: Maybe<Boolean>;
  inventory_not?: Maybe<Boolean>;
  owner?: Maybe<Int>;
  owner_not?: Maybe<Int>;
  owner_in?: Maybe<Int[] | Int>;
  owner_not_in?: Maybe<Int[] | Int>;
  owner_lt?: Maybe<Int>;
  owner_lte?: Maybe<Int>;
  owner_gt?: Maybe<Int>;
  owner_gte?: Maybe<Int>;
  gender?: Maybe<Boolean>;
  gender_not?: Maybe<Boolean>;
  figure?: Maybe<String>;
  figure_not?: Maybe<String>;
  figure_in?: Maybe<String[] | String>;
  figure_not_in?: Maybe<String[] | String>;
  figure_lt?: Maybe<String>;
  figure_lte?: Maybe<String>;
  figure_gt?: Maybe<String>;
  figure_gte?: Maybe<String>;
  figure_contains?: Maybe<String>;
  figure_not_contains?: Maybe<String>;
  figure_starts_with?: Maybe<String>;
  figure_not_starts_with?: Maybe<String>;
  figure_ends_with?: Maybe<String>;
  figure_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  messages?: Maybe<String>;
  messages_not?: Maybe<String>;
  messages_in?: Maybe<String[] | String>;
  messages_not_in?: Maybe<String[] | String>;
  messages_lt?: Maybe<String>;
  messages_lte?: Maybe<String>;
  messages_gt?: Maybe<String>;
  messages_gte?: Maybe<String>;
  messages_contains?: Maybe<String>;
  messages_not_contains?: Maybe<String>;
  messages_starts_with?: Maybe<String>;
  messages_not_starts_with?: Maybe<String>;
  messages_ends_with?: Maybe<String>;
  messages_not_ends_with?: Maybe<String>;
  chatBubble?: Maybe<Int>;
  chatBubble_not?: Maybe<Int>;
  chatBubble_in?: Maybe<Int[] | Int>;
  chatBubble_not_in?: Maybe<Int[] | Int>;
  chatBubble_lt?: Maybe<Int>;
  chatBubble_lte?: Maybe<Int>;
  chatBubble_gt?: Maybe<Int>;
  chatBubble_gte?: Maybe<Int>;
  chatAuto?: Maybe<Int>;
  chatAuto_not?: Maybe<Int>;
  chatAuto_in?: Maybe<Int[] | Int>;
  chatAuto_not_in?: Maybe<Int[] | Int>;
  chatAuto_lt?: Maybe<Int>;
  chatAuto_lte?: Maybe<Int>;
  chatAuto_gt?: Maybe<Int>;
  chatAuto_gte?: Maybe<Int>;
  chatRandom?: Maybe<Boolean>;
  chatRandom_not?: Maybe<Boolean>;
  chatDelay?: Maybe<Int>;
  chatDelay_not?: Maybe<Int>;
  chatDelay_in?: Maybe<Int[] | Int>;
  chatDelay_not_in?: Maybe<Int[] | Int>;
  chatDelay_lt?: Maybe<Int>;
  chatDelay_lte?: Maybe<Int>;
  chatDelay_gt?: Maybe<Int>;
  chatDelay_gte?: Maybe<Int>;
  AND?: Maybe<BotWhereInput[] | BotWhereInput>;
  OR?: Maybe<BotWhereInput[] | BotWhereInput>;
  NOT?: Maybe<BotWhereInput[] | BotWhereInput>;
}

export type CatalogItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CatalogItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  page?: Maybe<Int>;
  page_not?: Maybe<Int>;
  page_in?: Maybe<Int[] | Int>;
  page_not_in?: Maybe<Int[] | Int>;
  page_lt?: Maybe<Int>;
  page_lte?: Maybe<Int>;
  page_gt?: Maybe<Int>;
  page_gte?: Maybe<Int>;
  item?: Maybe<Int>;
  item_not?: Maybe<Int>;
  item_in?: Maybe<Int[] | Int>;
  item_not_in?: Maybe<Int[] | Int>;
  item_lt?: Maybe<Int>;
  item_lte?: Maybe<Int>;
  item_gt?: Maybe<Int>;
  item_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  limited?: Maybe<Boolean>;
  limited_not?: Maybe<Boolean>;
  maximum?: Maybe<Int>;
  maximum_not?: Maybe<Int>;
  maximum_in?: Maybe<Int[] | Int>;
  maximum_not_in?: Maybe<Int[] | Int>;
  maximum_lt?: Maybe<Int>;
  maximum_lte?: Maybe<Int>;
  maximum_gt?: Maybe<Int>;
  maximum_gte?: Maybe<Int>;
  stack?: Maybe<Boolean>;
  stack_not?: Maybe<Boolean>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  AND?: Maybe<CatalogItemWhereInput[] | CatalogItemWhereInput>;
  OR?: Maybe<CatalogItemWhereInput[] | CatalogItemWhereInput>;
  NOT?: Maybe<CatalogItemWhereInput[] | CatalogItemWhereInput>;
}

export type CatalogPageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CatalogPageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  parent?: Maybe<Int>;
  parent_not?: Maybe<Int>;
  parent_in?: Maybe<Int[] | Int>;
  parent_not_in?: Maybe<Int[] | Int>;
  parent_lt?: Maybe<Int>;
  parent_lte?: Maybe<Int>;
  parent_gt?: Maybe<Int>;
  parent_gte?: Maybe<Int>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  caption?: Maybe<String>;
  caption_not?: Maybe<String>;
  caption_in?: Maybe<String[] | String>;
  caption_not_in?: Maybe<String[] | String>;
  caption_lt?: Maybe<String>;
  caption_lte?: Maybe<String>;
  caption_gt?: Maybe<String>;
  caption_gte?: Maybe<String>;
  caption_contains?: Maybe<String>;
  caption_not_contains?: Maybe<String>;
  caption_starts_with?: Maybe<String>;
  caption_not_starts_with?: Maybe<String>;
  caption_ends_with?: Maybe<String>;
  caption_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  icon?: Maybe<String>;
  icon_not?: Maybe<String>;
  icon_in?: Maybe<String[] | String>;
  icon_not_in?: Maybe<String[] | String>;
  icon_lt?: Maybe<String>;
  icon_lte?: Maybe<String>;
  icon_gt?: Maybe<String>;
  icon_gte?: Maybe<String>;
  icon_contains?: Maybe<String>;
  icon_not_contains?: Maybe<String>;
  icon_starts_with?: Maybe<String>;
  icon_not_starts_with?: Maybe<String>;
  icon_ends_with?: Maybe<String>;
  icon_not_ends_with?: Maybe<String>;
  visible?: Maybe<Boolean>;
  visible_not?: Maybe<Boolean>;
  enabled?: Maybe<Boolean>;
  enabled_not?: Maybe<Boolean>;
  rank?: Maybe<Int>;
  rank_not?: Maybe<Int>;
  rank_in?: Maybe<Int[] | Int>;
  rank_not_in?: Maybe<Int[] | Int>;
  rank_lt?: Maybe<Int>;
  rank_lte?: Maybe<Int>;
  rank_gt?: Maybe<Int>;
  rank_gte?: Maybe<Int>;
  club?: Maybe<Boolean>;
  club_not?: Maybe<Boolean>;
  vip?: Maybe<Boolean>;
  vip_not?: Maybe<Boolean>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  AND?: Maybe<CatalogPageWhereInput[] | CatalogPageWhereInput>;
  OR?: Maybe<CatalogPageWhereInput[] | CatalogPageWhereInput>;
  NOT?: Maybe<CatalogPageWhereInput[] | CatalogPageWhereInput>;
}

export type ItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  owner?: Maybe<Int>;
  owner_not?: Maybe<Int>;
  owner_in?: Maybe<Int[] | Int>;
  owner_not_in?: Maybe<Int[] | Int>;
  owner_lt?: Maybe<Int>;
  owner_lte?: Maybe<Int>;
  owner_gt?: Maybe<Int>;
  owner_gte?: Maybe<Int>;
  room?: Maybe<RoomWhereInput>;
  furniture?: Maybe<Int>;
  furniture_not?: Maybe<Int>;
  furniture_in?: Maybe<Int[] | Int>;
  furniture_not_in?: Maybe<Int[] | Int>;
  furniture_lt?: Maybe<Int>;
  furniture_lte?: Maybe<Int>;
  furniture_gt?: Maybe<Int>;
  furniture_gte?: Maybe<Int>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  x?: Maybe<Int>;
  x_not?: Maybe<Int>;
  x_in?: Maybe<Int[] | Int>;
  x_not_in?: Maybe<Int[] | Int>;
  x_lt?: Maybe<Int>;
  x_lte?: Maybe<Int>;
  x_gt?: Maybe<Int>;
  x_gte?: Maybe<Int>;
  y?: Maybe<Int>;
  y_not?: Maybe<Int>;
  y_in?: Maybe<Int[] | Int>;
  y_not_in?: Maybe<Int[] | Int>;
  y_lt?: Maybe<Int>;
  y_lte?: Maybe<Int>;
  y_gt?: Maybe<Int>;
  y_gte?: Maybe<Int>;
  z?: Maybe<Int>;
  z_not?: Maybe<Int>;
  z_in?: Maybe<Int[] | Int>;
  z_not_in?: Maybe<Int[] | Int>;
  z_lt?: Maybe<Int>;
  z_lte?: Maybe<Int>;
  z_gt?: Maybe<Int>;
  z_gte?: Maybe<Int>;
  rotation?: Maybe<Int>;
  rotation_not?: Maybe<Int>;
  rotation_in?: Maybe<Int[] | Int>;
  rotation_not_in?: Maybe<Int[] | Int>;
  rotation_lt?: Maybe<Int>;
  rotation_lte?: Maybe<Int>;
  rotation_gt?: Maybe<Int>;
  rotation_gte?: Maybe<Int>;
  inventory?: Maybe<Boolean>;
  inventory_not?: Maybe<Boolean>;
  AND?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  OR?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  NOT?: Maybe<ItemWhereInput[] | ItemWhereInput>;
}

export interface RoomWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  type?: Maybe<roomType>;
  type_not?: Maybe<roomType>;
  type_in?: Maybe<roomType[] | roomType>;
  type_not_in?: Maybe<roomType[] | roomType>;
  category?: Maybe<Int>;
  category_not?: Maybe<Int>;
  category_in?: Maybe<Int[] | Int>;
  category_not_in?: Maybe<Int[] | Int>;
  category_lt?: Maybe<Int>;
  category_lte?: Maybe<Int>;
  category_gt?: Maybe<Int>;
  category_gte?: Maybe<Int>;
  owner?: Maybe<Int>;
  owner_not?: Maybe<Int>;
  owner_in?: Maybe<Int[] | Int>;
  owner_not_in?: Maybe<Int[] | Int>;
  owner_lt?: Maybe<Int>;
  owner_lte?: Maybe<Int>;
  owner_gt?: Maybe<Int>;
  owner_gte?: Maybe<Int>;
  floorThickness?: Maybe<Int>;
  floorThickness_not?: Maybe<Int>;
  floorThickness_in?: Maybe<Int[] | Int>;
  floorThickness_not_in?: Maybe<Int[] | Int>;
  floorThickness_lt?: Maybe<Int>;
  floorThickness_lte?: Maybe<Int>;
  floorThickness_gt?: Maybe<Int>;
  floorThickness_gte?: Maybe<Int>;
  wallThickness?: Maybe<Int>;
  wallThickness_not?: Maybe<Int>;
  wallThickness_in?: Maybe<Int[] | Int>;
  wallThickness_not_in?: Maybe<Int[] | Int>;
  wallThickness_lt?: Maybe<Int>;
  wallThickness_lte?: Maybe<Int>;
  wallThickness_gt?: Maybe<Int>;
  wallThickness_gte?: Maybe<Int>;
  wallHeight?: Maybe<Int>;
  wallHeight_not?: Maybe<Int>;
  wallHeight_in?: Maybe<Int[] | Int>;
  wallHeight_not_in?: Maybe<Int[] | Int>;
  wallHeight_lt?: Maybe<Int>;
  wallHeight_lte?: Maybe<Int>;
  wallHeight_gt?: Maybe<Int>;
  wallHeight_gte?: Maybe<Int>;
  hideWalls?: Maybe<Boolean>;
  hideWalls_not?: Maybe<Boolean>;
  hideWired?: Maybe<Boolean>;
  hideWired_not?: Maybe<Boolean>;
  maxUsers?: Maybe<Int>;
  maxUsers_not?: Maybe<Int>;
  maxUsers_in?: Maybe<Int[] | Int>;
  maxUsers_not_in?: Maybe<Int[] | Int>;
  maxUsers_lt?: Maybe<Int>;
  maxUsers_lte?: Maybe<Int>;
  maxUsers_gt?: Maybe<Int>;
  maxUsers_gte?: Maybe<Int>;
  allowPets?: Maybe<Boolean>;
  allowPets_not?: Maybe<Boolean>;
  allowPetsEating?: Maybe<Boolean>;
  allowPetsEating_not?: Maybe<Boolean>;
  items_every?: Maybe<ItemWhereInput>;
  items_some?: Maybe<ItemWhereInput>;
  items_none?: Maybe<ItemWhereInput>;
  AND?: Maybe<RoomWhereInput[] | RoomWhereInput>;
  OR?: Maybe<RoomWhereInput[] | RoomWhereInput>;
  NOT?: Maybe<RoomWhereInput[] | RoomWhereInput>;
}

export type RoomWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  username?: Maybe<String>;
}>;

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  pin?: Maybe<Int>;
  pin_not?: Maybe<Int>;
  pin_in?: Maybe<Int[] | Int>;
  pin_not_in?: Maybe<Int[] | Int>;
  pin_lt?: Maybe<Int>;
  pin_lte?: Maybe<Int>;
  pin_gt?: Maybe<Int>;
  pin_gte?: Maybe<Int>;
  motto?: Maybe<String>;
  motto_not?: Maybe<String>;
  motto_in?: Maybe<String[] | String>;
  motto_not_in?: Maybe<String[] | String>;
  motto_lt?: Maybe<String>;
  motto_lte?: Maybe<String>;
  motto_gt?: Maybe<String>;
  motto_gte?: Maybe<String>;
  motto_contains?: Maybe<String>;
  motto_not_contains?: Maybe<String>;
  motto_starts_with?: Maybe<String>;
  motto_not_starts_with?: Maybe<String>;
  motto_ends_with?: Maybe<String>;
  motto_not_ends_with?: Maybe<String>;
  figure?: Maybe<String>;
  figure_not?: Maybe<String>;
  figure_in?: Maybe<String[] | String>;
  figure_not_in?: Maybe<String[] | String>;
  figure_lt?: Maybe<String>;
  figure_lte?: Maybe<String>;
  figure_gt?: Maybe<String>;
  figure_gte?: Maybe<String>;
  figure_contains?: Maybe<String>;
  figure_not_contains?: Maybe<String>;
  figure_starts_with?: Maybe<String>;
  figure_not_starts_with?: Maybe<String>;
  figure_ends_with?: Maybe<String>;
  figure_not_ends_with?: Maybe<String>;
  rank?: Maybe<Int>;
  rank_not?: Maybe<Int>;
  rank_in?: Maybe<Int[] | Int>;
  rank_not_in?: Maybe<Int[] | Int>;
  rank_lt?: Maybe<Int>;
  rank_lte?: Maybe<Int>;
  rank_gt?: Maybe<Int>;
  rank_gte?: Maybe<Int>;
  vip?: Maybe<Int>;
  vip_not?: Maybe<Int>;
  vip_in?: Maybe<Int[] | Int>;
  vip_not_in?: Maybe<Int[] | Int>;
  vip_lt?: Maybe<Int>;
  vip_lte?: Maybe<Int>;
  vip_gt?: Maybe<Int>;
  vip_gte?: Maybe<Int>;
  online?: Maybe<Boolean>;
  online_not?: Maybe<Boolean>;
  verified?: Maybe<Int>;
  verified_not?: Maybe<Int>;
  verified_in?: Maybe<Int[] | Int>;
  verified_not_in?: Maybe<Int[] | Int>;
  verified_lt?: Maybe<Int>;
  verified_lte?: Maybe<Int>;
  verified_gt?: Maybe<Int>;
  verified_gte?: Maybe<Int>;
  home?: Maybe<Int>;
  home_not?: Maybe<Int>;
  home_in?: Maybe<Int[] | Int>;
  home_not_in?: Maybe<Int[] | Int>;
  home_lt?: Maybe<Int>;
  home_lte?: Maybe<Int>;
  home_gt?: Maybe<Int>;
  home_gte?: Maybe<Int>;
  volume?: Maybe<Int>;
  volume_not?: Maybe<Int>;
  volume_in?: Maybe<Int[] | Int>;
  volume_not_in?: Maybe<Int[] | Int>;
  volume_lt?: Maybe<Int>;
  volume_lte?: Maybe<Int>;
  volume_gt?: Maybe<Int>;
  volume_gte?: Maybe<Int>;
  muted?: Maybe<Boolean>;
  muted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface BadgeCreateInput {
  id?: Maybe<ID_Input>;
  code: String;
  description?: Maybe<String>;
}

export interface BadgeUpdateInput {
  code?: Maybe<String>;
  description?: Maybe<String>;
}

export interface BadgeUpdateManyMutationInput {
  code?: Maybe<String>;
  description?: Maybe<String>;
}

export interface BanCreateInput {
  id?: Maybe<ID_Input>;
  reason?: Maybe<String>;
  status?: Maybe<banStatus>;
  type?: Maybe<banType>;
  user?: Maybe<Int>;
  ip?: Maybe<String>;
  machine?: Maybe<String>;
  by?: Maybe<Int>;
}

export interface BanUpdateInput {
  reason?: Maybe<String>;
  status?: Maybe<banStatus>;
  type?: Maybe<banType>;
  user?: Maybe<Int>;
  ip?: Maybe<String>;
  machine?: Maybe<String>;
  by?: Maybe<Int>;
}

export interface BanUpdateManyMutationInput {
  reason?: Maybe<String>;
  status?: Maybe<banStatus>;
  type?: Maybe<banType>;
  user?: Maybe<Int>;
  ip?: Maybe<String>;
  machine?: Maybe<String>;
  by?: Maybe<Int>;
}

export interface BotCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  motto?: Maybe<String>;
  inventory?: Maybe<Boolean>;
  owner?: Maybe<Int>;
  gender?: Maybe<Boolean>;
  figure?: Maybe<String>;
  type?: Maybe<String>;
  state?: Maybe<BotCreatestateInput>;
  action?: Maybe<BotCreateactionInput>;
  position?: Maybe<BotCreatepositionInput>;
  messages?: Maybe<String>;
  chatBubble?: Maybe<Int>;
  chatAuto?: Maybe<Int>;
  chatRandom?: Maybe<Boolean>;
  chatDelay?: Maybe<Int>;
}

export interface BotCreatestateInput {
  set?: Maybe<String[] | String>;
}

export interface BotCreateactionInput {
  set?: Maybe<String[] | String>;
}

export interface BotCreatepositionInput {
  set?: Maybe<Int[] | Int>;
}

export interface BotUpdateInput {
  name?: Maybe<String>;
  motto?: Maybe<String>;
  inventory?: Maybe<Boolean>;
  owner?: Maybe<Int>;
  gender?: Maybe<Boolean>;
  figure?: Maybe<String>;
  type?: Maybe<String>;
  state?: Maybe<BotUpdatestateInput>;
  action?: Maybe<BotUpdateactionInput>;
  position?: Maybe<BotUpdatepositionInput>;
  messages?: Maybe<String>;
  chatBubble?: Maybe<Int>;
  chatAuto?: Maybe<Int>;
  chatRandom?: Maybe<Boolean>;
  chatDelay?: Maybe<Int>;
}

export interface BotUpdatestateInput {
  set?: Maybe<String[] | String>;
}

export interface BotUpdateactionInput {
  set?: Maybe<String[] | String>;
}

export interface BotUpdatepositionInput {
  set?: Maybe<Int[] | Int>;
}

export interface BotUpdateManyMutationInput {
  name?: Maybe<String>;
  motto?: Maybe<String>;
  inventory?: Maybe<Boolean>;
  owner?: Maybe<Int>;
  gender?: Maybe<Boolean>;
  figure?: Maybe<String>;
  type?: Maybe<String>;
  state?: Maybe<BotUpdatestateInput>;
  action?: Maybe<BotUpdateactionInput>;
  position?: Maybe<BotUpdatepositionInput>;
  messages?: Maybe<String>;
  chatBubble?: Maybe<Int>;
  chatAuto?: Maybe<Int>;
  chatRandom?: Maybe<Boolean>;
  chatDelay?: Maybe<Int>;
}

export interface CatalogItemCreateInput {
  id?: Maybe<ID_Input>;
  page?: Maybe<Int>;
  item?: Maybe<Int>;
  name?: Maybe<String>;
  amount?: Maybe<Int>;
  limited?: Maybe<Boolean>;
  maximum?: Maybe<Int>;
  stack?: Maybe<Boolean>;
  active?: Maybe<Boolean>;
}

export interface CatalogItemUpdateInput {
  page?: Maybe<Int>;
  item?: Maybe<Int>;
  name?: Maybe<String>;
  amount?: Maybe<Int>;
  limited?: Maybe<Boolean>;
  maximum?: Maybe<Int>;
  stack?: Maybe<Boolean>;
  active?: Maybe<Boolean>;
}

export interface CatalogItemUpdateManyMutationInput {
  page?: Maybe<Int>;
  item?: Maybe<Int>;
  name?: Maybe<String>;
  amount?: Maybe<Int>;
  limited?: Maybe<Boolean>;
  maximum?: Maybe<Int>;
  stack?: Maybe<Boolean>;
  active?: Maybe<Boolean>;
}

export interface CatalogPageCreateInput {
  id?: Maybe<ID_Input>;
  parent?: Maybe<Int>;
  type?: Maybe<String>;
  order?: Maybe<Int>;
  name: String;
  caption?: Maybe<String>;
  description?: Maybe<String>;
  icon?: Maybe<String>;
  visible?: Maybe<Boolean>;
  enabled?: Maybe<Boolean>;
  rank?: Maybe<Int>;
  club?: Maybe<Boolean>;
  vip?: Maybe<Boolean>;
  body?: Maybe<String>;
}

export interface CatalogPageUpdateInput {
  parent?: Maybe<Int>;
  type?: Maybe<String>;
  order?: Maybe<Int>;
  name?: Maybe<String>;
  caption?: Maybe<String>;
  description?: Maybe<String>;
  icon?: Maybe<String>;
  visible?: Maybe<Boolean>;
  enabled?: Maybe<Boolean>;
  rank?: Maybe<Int>;
  club?: Maybe<Boolean>;
  vip?: Maybe<Boolean>;
  body?: Maybe<String>;
}

export interface CatalogPageUpdateManyMutationInput {
  parent?: Maybe<Int>;
  type?: Maybe<String>;
  order?: Maybe<Int>;
  name?: Maybe<String>;
  caption?: Maybe<String>;
  description?: Maybe<String>;
  icon?: Maybe<String>;
  visible?: Maybe<Boolean>;
  enabled?: Maybe<Boolean>;
  rank?: Maybe<Int>;
  club?: Maybe<Boolean>;
  vip?: Maybe<Boolean>;
  body?: Maybe<String>;
}

export interface ItemCreateInput {
  id?: Maybe<ID_Input>;
  owner?: Maybe<Int>;
  room: RoomCreateOneWithoutItemsInput;
  furniture?: Maybe<Int>;
  type?: Maybe<String>;
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  z?: Maybe<Int>;
  rotation?: Maybe<Int>;
  wallPosition?: Maybe<ItemCreatewallPositionInput>;
  inventory?: Maybe<Boolean>;
}

export interface RoomCreateOneWithoutItemsInput {
  create?: Maybe<RoomCreateWithoutItemsInput>;
  connect?: Maybe<RoomWhereUniqueInput>;
}

export interface RoomCreateWithoutItemsInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  type?: Maybe<roomType>;
  category?: Maybe<Int>;
  owner?: Maybe<Int>;
  map?: Maybe<Json>;
  floorThickness?: Maybe<Int>;
  wallThickness?: Maybe<Int>;
  wallHeight?: Maybe<Int>;
  hideWalls?: Maybe<Boolean>;
  hideWired?: Maybe<Boolean>;
  maxUsers?: Maybe<Int>;
  allowPets?: Maybe<Boolean>;
  allowPetsEating?: Maybe<Boolean>;
  rights?: Maybe<RoomCreaterightsInput>;
}

export interface RoomCreaterightsInput {
  set?: Maybe<Int[] | Int>;
}

export interface ItemCreatewallPositionInput {
  set?: Maybe<Float[] | Float>;
}

export interface ItemUpdateInput {
  owner?: Maybe<Int>;
  room?: Maybe<RoomUpdateOneRequiredWithoutItemsInput>;
  furniture?: Maybe<Int>;
  type?: Maybe<String>;
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  z?: Maybe<Int>;
  rotation?: Maybe<Int>;
  wallPosition?: Maybe<ItemUpdatewallPositionInput>;
  inventory?: Maybe<Boolean>;
}

export interface RoomUpdateOneRequiredWithoutItemsInput {
  create?: Maybe<RoomCreateWithoutItemsInput>;
  update?: Maybe<RoomUpdateWithoutItemsDataInput>;
  upsert?: Maybe<RoomUpsertWithoutItemsInput>;
  connect?: Maybe<RoomWhereUniqueInput>;
}

export interface RoomUpdateWithoutItemsDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  type?: Maybe<roomType>;
  category?: Maybe<Int>;
  owner?: Maybe<Int>;
  map?: Maybe<Json>;
  floorThickness?: Maybe<Int>;
  wallThickness?: Maybe<Int>;
  wallHeight?: Maybe<Int>;
  hideWalls?: Maybe<Boolean>;
  hideWired?: Maybe<Boolean>;
  maxUsers?: Maybe<Int>;
  allowPets?: Maybe<Boolean>;
  allowPetsEating?: Maybe<Boolean>;
  rights?: Maybe<RoomUpdaterightsInput>;
}

export interface RoomUpdaterightsInput {
  set?: Maybe<Int[] | Int>;
}

export interface RoomUpsertWithoutItemsInput {
  update: RoomUpdateWithoutItemsDataInput;
  create: RoomCreateWithoutItemsInput;
}

export interface ItemUpdatewallPositionInput {
  set?: Maybe<Float[] | Float>;
}

export interface ItemUpdateManyMutationInput {
  owner?: Maybe<Int>;
  furniture?: Maybe<Int>;
  type?: Maybe<String>;
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  z?: Maybe<Int>;
  rotation?: Maybe<Int>;
  wallPosition?: Maybe<ItemUpdatewallPositionInput>;
  inventory?: Maybe<Boolean>;
}

export interface RoomCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  type?: Maybe<roomType>;
  category?: Maybe<Int>;
  owner?: Maybe<Int>;
  map?: Maybe<Json>;
  floorThickness?: Maybe<Int>;
  wallThickness?: Maybe<Int>;
  wallHeight?: Maybe<Int>;
  hideWalls?: Maybe<Boolean>;
  hideWired?: Maybe<Boolean>;
  maxUsers?: Maybe<Int>;
  allowPets?: Maybe<Boolean>;
  allowPetsEating?: Maybe<Boolean>;
  rights?: Maybe<RoomCreaterightsInput>;
  items?: Maybe<ItemCreateManyWithoutRoomInput>;
}

export interface ItemCreateManyWithoutRoomInput {
  create?: Maybe<ItemCreateWithoutRoomInput[] | ItemCreateWithoutRoomInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
}

export interface ItemCreateWithoutRoomInput {
  id?: Maybe<ID_Input>;
  owner?: Maybe<Int>;
  furniture?: Maybe<Int>;
  type?: Maybe<String>;
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  z?: Maybe<Int>;
  rotation?: Maybe<Int>;
  wallPosition?: Maybe<ItemCreatewallPositionInput>;
  inventory?: Maybe<Boolean>;
}

export interface RoomUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  type?: Maybe<roomType>;
  category?: Maybe<Int>;
  owner?: Maybe<Int>;
  map?: Maybe<Json>;
  floorThickness?: Maybe<Int>;
  wallThickness?: Maybe<Int>;
  wallHeight?: Maybe<Int>;
  hideWalls?: Maybe<Boolean>;
  hideWired?: Maybe<Boolean>;
  maxUsers?: Maybe<Int>;
  allowPets?: Maybe<Boolean>;
  allowPetsEating?: Maybe<Boolean>;
  rights?: Maybe<RoomUpdaterightsInput>;
  items?: Maybe<ItemUpdateManyWithoutRoomInput>;
}

export interface ItemUpdateManyWithoutRoomInput {
  create?: Maybe<ItemCreateWithoutRoomInput[] | ItemCreateWithoutRoomInput>;
  delete?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  set?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  disconnect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  update?: Maybe<
    | ItemUpdateWithWhereUniqueWithoutRoomInput[]
    | ItemUpdateWithWhereUniqueWithoutRoomInput
  >;
  upsert?: Maybe<
    | ItemUpsertWithWhereUniqueWithoutRoomInput[]
    | ItemUpsertWithWhereUniqueWithoutRoomInput
  >;
  deleteMany?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  updateMany?: Maybe<
    ItemUpdateManyWithWhereNestedInput[] | ItemUpdateManyWithWhereNestedInput
  >;
}

export interface ItemUpdateWithWhereUniqueWithoutRoomInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateWithoutRoomDataInput;
}

export interface ItemUpdateWithoutRoomDataInput {
  owner?: Maybe<Int>;
  furniture?: Maybe<Int>;
  type?: Maybe<String>;
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  z?: Maybe<Int>;
  rotation?: Maybe<Int>;
  wallPosition?: Maybe<ItemUpdatewallPositionInput>;
  inventory?: Maybe<Boolean>;
}

export interface ItemUpsertWithWhereUniqueWithoutRoomInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateWithoutRoomDataInput;
  create: ItemCreateWithoutRoomInput;
}

export interface ItemScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  owner?: Maybe<Int>;
  owner_not?: Maybe<Int>;
  owner_in?: Maybe<Int[] | Int>;
  owner_not_in?: Maybe<Int[] | Int>;
  owner_lt?: Maybe<Int>;
  owner_lte?: Maybe<Int>;
  owner_gt?: Maybe<Int>;
  owner_gte?: Maybe<Int>;
  furniture?: Maybe<Int>;
  furniture_not?: Maybe<Int>;
  furniture_in?: Maybe<Int[] | Int>;
  furniture_not_in?: Maybe<Int[] | Int>;
  furniture_lt?: Maybe<Int>;
  furniture_lte?: Maybe<Int>;
  furniture_gt?: Maybe<Int>;
  furniture_gte?: Maybe<Int>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  x?: Maybe<Int>;
  x_not?: Maybe<Int>;
  x_in?: Maybe<Int[] | Int>;
  x_not_in?: Maybe<Int[] | Int>;
  x_lt?: Maybe<Int>;
  x_lte?: Maybe<Int>;
  x_gt?: Maybe<Int>;
  x_gte?: Maybe<Int>;
  y?: Maybe<Int>;
  y_not?: Maybe<Int>;
  y_in?: Maybe<Int[] | Int>;
  y_not_in?: Maybe<Int[] | Int>;
  y_lt?: Maybe<Int>;
  y_lte?: Maybe<Int>;
  y_gt?: Maybe<Int>;
  y_gte?: Maybe<Int>;
  z?: Maybe<Int>;
  z_not?: Maybe<Int>;
  z_in?: Maybe<Int[] | Int>;
  z_not_in?: Maybe<Int[] | Int>;
  z_lt?: Maybe<Int>;
  z_lte?: Maybe<Int>;
  z_gt?: Maybe<Int>;
  z_gte?: Maybe<Int>;
  rotation?: Maybe<Int>;
  rotation_not?: Maybe<Int>;
  rotation_in?: Maybe<Int[] | Int>;
  rotation_not_in?: Maybe<Int[] | Int>;
  rotation_lt?: Maybe<Int>;
  rotation_lte?: Maybe<Int>;
  rotation_gt?: Maybe<Int>;
  rotation_gte?: Maybe<Int>;
  inventory?: Maybe<Boolean>;
  inventory_not?: Maybe<Boolean>;
  AND?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  OR?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  NOT?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
}

export interface ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput;
  data: ItemUpdateManyDataInput;
}

export interface ItemUpdateManyDataInput {
  owner?: Maybe<Int>;
  furniture?: Maybe<Int>;
  type?: Maybe<String>;
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  z?: Maybe<Int>;
  rotation?: Maybe<Int>;
  wallPosition?: Maybe<ItemUpdatewallPositionInput>;
  inventory?: Maybe<Boolean>;
}

export interface RoomUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  type?: Maybe<roomType>;
  category?: Maybe<Int>;
  owner?: Maybe<Int>;
  map?: Maybe<Json>;
  floorThickness?: Maybe<Int>;
  wallThickness?: Maybe<Int>;
  wallHeight?: Maybe<Int>;
  hideWalls?: Maybe<Boolean>;
  hideWired?: Maybe<Boolean>;
  maxUsers?: Maybe<Int>;
  allowPets?: Maybe<Boolean>;
  allowPetsEating?: Maybe<Boolean>;
  rights?: Maybe<RoomUpdaterightsInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  username: String;
  email?: Maybe<String>;
  password?: Maybe<String>;
  pin?: Maybe<Int>;
  motto?: Maybe<String>;
  figure?: Maybe<String>;
  rank?: Maybe<Int>;
  vip?: Maybe<Int>;
  online?: Maybe<Boolean>;
  verified?: Maybe<Int>;
  home?: Maybe<Int>;
  volume?: Maybe<Int>;
  muted?: Maybe<Boolean>;
}

export interface UserUpdateInput {
  username?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  pin?: Maybe<Int>;
  motto?: Maybe<String>;
  figure?: Maybe<String>;
  rank?: Maybe<Int>;
  vip?: Maybe<Int>;
  online?: Maybe<Boolean>;
  verified?: Maybe<Int>;
  home?: Maybe<Int>;
  volume?: Maybe<Int>;
  muted?: Maybe<Boolean>;
}

export interface UserUpdateManyMutationInput {
  username?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  pin?: Maybe<Int>;
  motto?: Maybe<String>;
  figure?: Maybe<String>;
  rank?: Maybe<Int>;
  vip?: Maybe<Int>;
  online?: Maybe<Boolean>;
  verified?: Maybe<Int>;
  home?: Maybe<Int>;
  volume?: Maybe<Int>;
  muted?: Maybe<Boolean>;
}

export interface BadgeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BadgeWhereInput>;
  AND?: Maybe<BadgeSubscriptionWhereInput[] | BadgeSubscriptionWhereInput>;
  OR?: Maybe<BadgeSubscriptionWhereInput[] | BadgeSubscriptionWhereInput>;
  NOT?: Maybe<BadgeSubscriptionWhereInput[] | BadgeSubscriptionWhereInput>;
}

export interface BanSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BanWhereInput>;
  AND?: Maybe<BanSubscriptionWhereInput[] | BanSubscriptionWhereInput>;
  OR?: Maybe<BanSubscriptionWhereInput[] | BanSubscriptionWhereInput>;
  NOT?: Maybe<BanSubscriptionWhereInput[] | BanSubscriptionWhereInput>;
}

export interface BotSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BotWhereInput>;
  AND?: Maybe<BotSubscriptionWhereInput[] | BotSubscriptionWhereInput>;
  OR?: Maybe<BotSubscriptionWhereInput[] | BotSubscriptionWhereInput>;
  NOT?: Maybe<BotSubscriptionWhereInput[] | BotSubscriptionWhereInput>;
}

export interface CatalogItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CatalogItemWhereInput>;
  AND?: Maybe<
    CatalogItemSubscriptionWhereInput[] | CatalogItemSubscriptionWhereInput
  >;
  OR?: Maybe<
    CatalogItemSubscriptionWhereInput[] | CatalogItemSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CatalogItemSubscriptionWhereInput[] | CatalogItemSubscriptionWhereInput
  >;
}

export interface CatalogPageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CatalogPageWhereInput>;
  AND?: Maybe<
    CatalogPageSubscriptionWhereInput[] | CatalogPageSubscriptionWhereInput
  >;
  OR?: Maybe<
    CatalogPageSubscriptionWhereInput[] | CatalogPageSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CatalogPageSubscriptionWhereInput[] | CatalogPageSubscriptionWhereInput
  >;
}

export interface ItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ItemWhereInput>;
  AND?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  OR?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  NOT?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
}

export interface RoomSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RoomWhereInput>;
  AND?: Maybe<RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput>;
  OR?: Maybe<RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput>;
  NOT?: Maybe<RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Badge {
  id: ID_Output;
  code: String;
  description?: String;
}

export interface BadgePromise extends Promise<Badge>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  description: () => Promise<String>;
}

export interface BadgeSubscription
  extends Promise<AsyncIterator<Badge>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface BadgeNullablePromise
  extends Promise<Badge | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  description: () => Promise<String>;
}

export interface BadgeConnection {
  pageInfo: PageInfo;
  edges: BadgeEdge[];
}

export interface BadgeConnectionPromise
  extends Promise<BadgeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BadgeEdge>>() => T;
  aggregate: <T = AggregateBadgePromise>() => T;
}

export interface BadgeConnectionSubscription
  extends Promise<AsyncIterator<BadgeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BadgeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBadgeSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BadgeEdge {
  node: Badge;
  cursor: String;
}

export interface BadgeEdgePromise extends Promise<BadgeEdge>, Fragmentable {
  node: <T = BadgePromise>() => T;
  cursor: () => Promise<String>;
}

export interface BadgeEdgeSubscription
  extends Promise<AsyncIterator<BadgeEdge>>,
    Fragmentable {
  node: <T = BadgeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBadge {
  count: Int;
}

export interface AggregateBadgePromise
  extends Promise<AggregateBadge>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBadgeSubscription
  extends Promise<AsyncIterator<AggregateBadge>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Ban {
  id: ID_Output;
  reason?: String;
  status?: banStatus;
  type?: banType;
  user?: Int;
  ip?: String;
  machine?: String;
  by?: Int;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface BanPromise extends Promise<Ban>, Fragmentable {
  id: () => Promise<ID_Output>;
  reason: () => Promise<String>;
  status: () => Promise<banStatus>;
  type: () => Promise<banType>;
  user: () => Promise<Int>;
  ip: () => Promise<String>;
  machine: () => Promise<String>;
  by: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BanSubscription
  extends Promise<AsyncIterator<Ban>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  reason: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<banStatus>>;
  type: () => Promise<AsyncIterator<banType>>;
  user: () => Promise<AsyncIterator<Int>>;
  ip: () => Promise<AsyncIterator<String>>;
  machine: () => Promise<AsyncIterator<String>>;
  by: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BanNullablePromise extends Promise<Ban | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  reason: () => Promise<String>;
  status: () => Promise<banStatus>;
  type: () => Promise<banType>;
  user: () => Promise<Int>;
  ip: () => Promise<String>;
  machine: () => Promise<String>;
  by: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BanConnection {
  pageInfo: PageInfo;
  edges: BanEdge[];
}

export interface BanConnectionPromise
  extends Promise<BanConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BanEdge>>() => T;
  aggregate: <T = AggregateBanPromise>() => T;
}

export interface BanConnectionSubscription
  extends Promise<AsyncIterator<BanConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BanEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBanSubscription>() => T;
}

export interface BanEdge {
  node: Ban;
  cursor: String;
}

export interface BanEdgePromise extends Promise<BanEdge>, Fragmentable {
  node: <T = BanPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BanEdgeSubscription
  extends Promise<AsyncIterator<BanEdge>>,
    Fragmentable {
  node: <T = BanSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBan {
  count: Int;
}

export interface AggregateBanPromise
  extends Promise<AggregateBan>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBanSubscription
  extends Promise<AsyncIterator<AggregateBan>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Bot {
  id: ID_Output;
  name?: String;
  motto?: String;
  inventory?: Boolean;
  owner?: Int;
  gender?: Boolean;
  figure?: String;
  type?: String;
  state: String[];
  action: String[];
  position: Int[];
  messages?: String;
  chatBubble?: Int;
  chatAuto?: Int;
  chatRandom?: Boolean;
  chatDelay?: Int;
}

export interface BotPromise extends Promise<Bot>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  motto: () => Promise<String>;
  inventory: () => Promise<Boolean>;
  owner: () => Promise<Int>;
  gender: () => Promise<Boolean>;
  figure: () => Promise<String>;
  type: () => Promise<String>;
  state: () => Promise<String[]>;
  action: () => Promise<String[]>;
  position: () => Promise<Int[]>;
  messages: () => Promise<String>;
  chatBubble: () => Promise<Int>;
  chatAuto: () => Promise<Int>;
  chatRandom: () => Promise<Boolean>;
  chatDelay: () => Promise<Int>;
}

export interface BotSubscription
  extends Promise<AsyncIterator<Bot>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  motto: () => Promise<AsyncIterator<String>>;
  inventory: () => Promise<AsyncIterator<Boolean>>;
  owner: () => Promise<AsyncIterator<Int>>;
  gender: () => Promise<AsyncIterator<Boolean>>;
  figure: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String[]>>;
  action: () => Promise<AsyncIterator<String[]>>;
  position: () => Promise<AsyncIterator<Int[]>>;
  messages: () => Promise<AsyncIterator<String>>;
  chatBubble: () => Promise<AsyncIterator<Int>>;
  chatAuto: () => Promise<AsyncIterator<Int>>;
  chatRandom: () => Promise<AsyncIterator<Boolean>>;
  chatDelay: () => Promise<AsyncIterator<Int>>;
}

export interface BotNullablePromise extends Promise<Bot | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  motto: () => Promise<String>;
  inventory: () => Promise<Boolean>;
  owner: () => Promise<Int>;
  gender: () => Promise<Boolean>;
  figure: () => Promise<String>;
  type: () => Promise<String>;
  state: () => Promise<String[]>;
  action: () => Promise<String[]>;
  position: () => Promise<Int[]>;
  messages: () => Promise<String>;
  chatBubble: () => Promise<Int>;
  chatAuto: () => Promise<Int>;
  chatRandom: () => Promise<Boolean>;
  chatDelay: () => Promise<Int>;
}

export interface BotConnection {
  pageInfo: PageInfo;
  edges: BotEdge[];
}

export interface BotConnectionPromise
  extends Promise<BotConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BotEdge>>() => T;
  aggregate: <T = AggregateBotPromise>() => T;
}

export interface BotConnectionSubscription
  extends Promise<AsyncIterator<BotConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BotEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBotSubscription>() => T;
}

export interface BotEdge {
  node: Bot;
  cursor: String;
}

export interface BotEdgePromise extends Promise<BotEdge>, Fragmentable {
  node: <T = BotPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BotEdgeSubscription
  extends Promise<AsyncIterator<BotEdge>>,
    Fragmentable {
  node: <T = BotSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBot {
  count: Int;
}

export interface AggregateBotPromise
  extends Promise<AggregateBot>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBotSubscription
  extends Promise<AsyncIterator<AggregateBot>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CatalogItem {
  id: ID_Output;
  page?: Int;
  item?: Int;
  name?: String;
  amount?: Int;
  limited?: Boolean;
  maximum?: Int;
  stack?: Boolean;
  active?: Boolean;
}

export interface CatalogItemPromise extends Promise<CatalogItem>, Fragmentable {
  id: () => Promise<ID_Output>;
  page: () => Promise<Int>;
  item: () => Promise<Int>;
  name: () => Promise<String>;
  amount: () => Promise<Int>;
  limited: () => Promise<Boolean>;
  maximum: () => Promise<Int>;
  stack: () => Promise<Boolean>;
  active: () => Promise<Boolean>;
}

export interface CatalogItemSubscription
  extends Promise<AsyncIterator<CatalogItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  page: () => Promise<AsyncIterator<Int>>;
  item: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Int>>;
  limited: () => Promise<AsyncIterator<Boolean>>;
  maximum: () => Promise<AsyncIterator<Int>>;
  stack: () => Promise<AsyncIterator<Boolean>>;
  active: () => Promise<AsyncIterator<Boolean>>;
}

export interface CatalogItemNullablePromise
  extends Promise<CatalogItem | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  page: () => Promise<Int>;
  item: () => Promise<Int>;
  name: () => Promise<String>;
  amount: () => Promise<Int>;
  limited: () => Promise<Boolean>;
  maximum: () => Promise<Int>;
  stack: () => Promise<Boolean>;
  active: () => Promise<Boolean>;
}

export interface CatalogItemConnection {
  pageInfo: PageInfo;
  edges: CatalogItemEdge[];
}

export interface CatalogItemConnectionPromise
  extends Promise<CatalogItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CatalogItemEdge>>() => T;
  aggregate: <T = AggregateCatalogItemPromise>() => T;
}

export interface CatalogItemConnectionSubscription
  extends Promise<AsyncIterator<CatalogItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CatalogItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCatalogItemSubscription>() => T;
}

export interface CatalogItemEdge {
  node: CatalogItem;
  cursor: String;
}

export interface CatalogItemEdgePromise
  extends Promise<CatalogItemEdge>,
    Fragmentable {
  node: <T = CatalogItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CatalogItemEdgeSubscription
  extends Promise<AsyncIterator<CatalogItemEdge>>,
    Fragmentable {
  node: <T = CatalogItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCatalogItem {
  count: Int;
}

export interface AggregateCatalogItemPromise
  extends Promise<AggregateCatalogItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCatalogItemSubscription
  extends Promise<AsyncIterator<AggregateCatalogItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CatalogPage {
  id: ID_Output;
  parent?: Int;
  type?: String;
  order?: Int;
  name: String;
  caption?: String;
  description?: String;
  icon?: String;
  visible?: Boolean;
  enabled?: Boolean;
  rank?: Int;
  club?: Boolean;
  vip?: Boolean;
  body?: String;
}

export interface CatalogPagePromise extends Promise<CatalogPage>, Fragmentable {
  id: () => Promise<ID_Output>;
  parent: () => Promise<Int>;
  type: () => Promise<String>;
  order: () => Promise<Int>;
  name: () => Promise<String>;
  caption: () => Promise<String>;
  description: () => Promise<String>;
  icon: () => Promise<String>;
  visible: () => Promise<Boolean>;
  enabled: () => Promise<Boolean>;
  rank: () => Promise<Int>;
  club: () => Promise<Boolean>;
  vip: () => Promise<Boolean>;
  body: () => Promise<String>;
}

export interface CatalogPageSubscription
  extends Promise<AsyncIterator<CatalogPage>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parent: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  caption: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  icon: () => Promise<AsyncIterator<String>>;
  visible: () => Promise<AsyncIterator<Boolean>>;
  enabled: () => Promise<AsyncIterator<Boolean>>;
  rank: () => Promise<AsyncIterator<Int>>;
  club: () => Promise<AsyncIterator<Boolean>>;
  vip: () => Promise<AsyncIterator<Boolean>>;
  body: () => Promise<AsyncIterator<String>>;
}

export interface CatalogPageNullablePromise
  extends Promise<CatalogPage | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  parent: () => Promise<Int>;
  type: () => Promise<String>;
  order: () => Promise<Int>;
  name: () => Promise<String>;
  caption: () => Promise<String>;
  description: () => Promise<String>;
  icon: () => Promise<String>;
  visible: () => Promise<Boolean>;
  enabled: () => Promise<Boolean>;
  rank: () => Promise<Int>;
  club: () => Promise<Boolean>;
  vip: () => Promise<Boolean>;
  body: () => Promise<String>;
}

export interface CatalogPageConnection {
  pageInfo: PageInfo;
  edges: CatalogPageEdge[];
}

export interface CatalogPageConnectionPromise
  extends Promise<CatalogPageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CatalogPageEdge>>() => T;
  aggregate: <T = AggregateCatalogPagePromise>() => T;
}

export interface CatalogPageConnectionSubscription
  extends Promise<AsyncIterator<CatalogPageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CatalogPageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCatalogPageSubscription>() => T;
}

export interface CatalogPageEdge {
  node: CatalogPage;
  cursor: String;
}

export interface CatalogPageEdgePromise
  extends Promise<CatalogPageEdge>,
    Fragmentable {
  node: <T = CatalogPagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CatalogPageEdgeSubscription
  extends Promise<AsyncIterator<CatalogPageEdge>>,
    Fragmentable {
  node: <T = CatalogPageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCatalogPage {
  count: Int;
}

export interface AggregateCatalogPagePromise
  extends Promise<AggregateCatalogPage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCatalogPageSubscription
  extends Promise<AsyncIterator<AggregateCatalogPage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Item {
  id: ID_Output;
  owner?: Int;
  furniture?: Int;
  type?: String;
  x?: Int;
  y?: Int;
  z?: Int;
  rotation?: Int;
  wallPosition: Float[];
  inventory?: Boolean;
}

export interface ItemPromise extends Promise<Item>, Fragmentable {
  id: () => Promise<ID_Output>;
  owner: () => Promise<Int>;
  room: <T = RoomPromise>() => T;
  furniture: () => Promise<Int>;
  type: () => Promise<String>;
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  z: () => Promise<Int>;
  rotation: () => Promise<Int>;
  wallPosition: () => Promise<Float[]>;
  inventory: () => Promise<Boolean>;
}

export interface ItemSubscription
  extends Promise<AsyncIterator<Item>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  owner: () => Promise<AsyncIterator<Int>>;
  room: <T = RoomSubscription>() => T;
  furniture: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
  x: () => Promise<AsyncIterator<Int>>;
  y: () => Promise<AsyncIterator<Int>>;
  z: () => Promise<AsyncIterator<Int>>;
  rotation: () => Promise<AsyncIterator<Int>>;
  wallPosition: () => Promise<AsyncIterator<Float[]>>;
  inventory: () => Promise<AsyncIterator<Boolean>>;
}

export interface ItemNullablePromise
  extends Promise<Item | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  owner: () => Promise<Int>;
  room: <T = RoomPromise>() => T;
  furniture: () => Promise<Int>;
  type: () => Promise<String>;
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  z: () => Promise<Int>;
  rotation: () => Promise<Int>;
  wallPosition: () => Promise<Float[]>;
  inventory: () => Promise<Boolean>;
}

export interface Room {
  id: ID_Output;
  name: String;
  description?: String;
  type?: roomType;
  category?: Int;
  owner?: Int;
  map?: Json;
  floorThickness?: Int;
  wallThickness?: Int;
  wallHeight?: Int;
  hideWalls?: Boolean;
  hideWired?: Boolean;
  maxUsers?: Int;
  allowPets?: Boolean;
  allowPetsEating?: Boolean;
  rights: Int[];
}

export interface RoomPromise extends Promise<Room>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  type: () => Promise<roomType>;
  category: () => Promise<Int>;
  owner: () => Promise<Int>;
  map: () => Promise<Json>;
  floorThickness: () => Promise<Int>;
  wallThickness: () => Promise<Int>;
  wallHeight: () => Promise<Int>;
  hideWalls: () => Promise<Boolean>;
  hideWired: () => Promise<Boolean>;
  maxUsers: () => Promise<Int>;
  allowPets: () => Promise<Boolean>;
  allowPetsEating: () => Promise<Boolean>;
  rights: () => Promise<Int[]>;
  items: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RoomSubscription
  extends Promise<AsyncIterator<Room>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<roomType>>;
  category: () => Promise<AsyncIterator<Int>>;
  owner: () => Promise<AsyncIterator<Int>>;
  map: () => Promise<AsyncIterator<Json>>;
  floorThickness: () => Promise<AsyncIterator<Int>>;
  wallThickness: () => Promise<AsyncIterator<Int>>;
  wallHeight: () => Promise<AsyncIterator<Int>>;
  hideWalls: () => Promise<AsyncIterator<Boolean>>;
  hideWired: () => Promise<AsyncIterator<Boolean>>;
  maxUsers: () => Promise<AsyncIterator<Int>>;
  allowPets: () => Promise<AsyncIterator<Boolean>>;
  allowPetsEating: () => Promise<AsyncIterator<Boolean>>;
  rights: () => Promise<AsyncIterator<Int[]>>;
  items: <T = Promise<AsyncIterator<ItemSubscription>>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RoomNullablePromise
  extends Promise<Room | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  type: () => Promise<roomType>;
  category: () => Promise<Int>;
  owner: () => Promise<Int>;
  map: () => Promise<Json>;
  floorThickness: () => Promise<Int>;
  wallThickness: () => Promise<Int>;
  wallHeight: () => Promise<Int>;
  hideWalls: () => Promise<Boolean>;
  hideWired: () => Promise<Boolean>;
  maxUsers: () => Promise<Int>;
  allowPets: () => Promise<Boolean>;
  allowPetsEating: () => Promise<Boolean>;
  rights: () => Promise<Int[]>;
  items: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ItemConnection {
  pageInfo: PageInfo;
  edges: ItemEdge[];
}

export interface ItemConnectionPromise
  extends Promise<ItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ItemEdge>>() => T;
  aggregate: <T = AggregateItemPromise>() => T;
}

export interface ItemConnectionSubscription
  extends Promise<AsyncIterator<ItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateItemSubscription>() => T;
}

export interface ItemEdge {
  node: Item;
  cursor: String;
}

export interface ItemEdgePromise extends Promise<ItemEdge>, Fragmentable {
  node: <T = ItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ItemEdgeSubscription
  extends Promise<AsyncIterator<ItemEdge>>,
    Fragmentable {
  node: <T = ItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateItem {
  count: Int;
}

export interface AggregateItemPromise
  extends Promise<AggregateItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateItemSubscription
  extends Promise<AsyncIterator<AggregateItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RoomConnection {
  pageInfo: PageInfo;
  edges: RoomEdge[];
}

export interface RoomConnectionPromise
  extends Promise<RoomConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RoomEdge>>() => T;
  aggregate: <T = AggregateRoomPromise>() => T;
}

export interface RoomConnectionSubscription
  extends Promise<AsyncIterator<RoomConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RoomEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRoomSubscription>() => T;
}

export interface RoomEdge {
  node: Room;
  cursor: String;
}

export interface RoomEdgePromise extends Promise<RoomEdge>, Fragmentable {
  node: <T = RoomPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RoomEdgeSubscription
  extends Promise<AsyncIterator<RoomEdge>>,
    Fragmentable {
  node: <T = RoomSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRoom {
  count: Int;
}

export interface AggregateRoomPromise
  extends Promise<AggregateRoom>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRoomSubscription
  extends Promise<AsyncIterator<AggregateRoom>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  username: String;
  email?: String;
  password?: String;
  pin?: Int;
  motto?: String;
  figure?: String;
  rank?: Int;
  vip?: Int;
  online?: Boolean;
  verified?: Int;
  home?: Int;
  volume?: Int;
  muted?: Boolean;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  pin: () => Promise<Int>;
  motto: () => Promise<String>;
  figure: () => Promise<String>;
  rank: () => Promise<Int>;
  vip: () => Promise<Int>;
  online: () => Promise<Boolean>;
  verified: () => Promise<Int>;
  home: () => Promise<Int>;
  volume: () => Promise<Int>;
  muted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  pin: () => Promise<AsyncIterator<Int>>;
  motto: () => Promise<AsyncIterator<String>>;
  figure: () => Promise<AsyncIterator<String>>;
  rank: () => Promise<AsyncIterator<Int>>;
  vip: () => Promise<AsyncIterator<Int>>;
  online: () => Promise<AsyncIterator<Boolean>>;
  verified: () => Promise<AsyncIterator<Int>>;
  home: () => Promise<AsyncIterator<Int>>;
  volume: () => Promise<AsyncIterator<Int>>;
  muted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  pin: () => Promise<Int>;
  motto: () => Promise<String>;
  figure: () => Promise<String>;
  rank: () => Promise<Int>;
  vip: () => Promise<Int>;
  online: () => Promise<Boolean>;
  verified: () => Promise<Int>;
  home: () => Promise<Int>;
  volume: () => Promise<Int>;
  muted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface BadgeSubscriptionPayload {
  mutation: MutationType;
  node: Badge;
  updatedFields: String[];
  previousValues: BadgePreviousValues;
}

export interface BadgeSubscriptionPayloadPromise
  extends Promise<BadgeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BadgePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BadgePreviousValuesPromise>() => T;
}

export interface BadgeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BadgeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BadgeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BadgePreviousValuesSubscription>() => T;
}

export interface BadgePreviousValues {
  id: ID_Output;
  code: String;
  description?: String;
}

export interface BadgePreviousValuesPromise
  extends Promise<BadgePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  description: () => Promise<String>;
}

export interface BadgePreviousValuesSubscription
  extends Promise<AsyncIterator<BadgePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface BanSubscriptionPayload {
  mutation: MutationType;
  node: Ban;
  updatedFields: String[];
  previousValues: BanPreviousValues;
}

export interface BanSubscriptionPayloadPromise
  extends Promise<BanSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BanPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BanPreviousValuesPromise>() => T;
}

export interface BanSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BanSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BanSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BanPreviousValuesSubscription>() => T;
}

export interface BanPreviousValues {
  id: ID_Output;
  reason?: String;
  status?: banStatus;
  type?: banType;
  user?: Int;
  ip?: String;
  machine?: String;
  by?: Int;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface BanPreviousValuesPromise
  extends Promise<BanPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  reason: () => Promise<String>;
  status: () => Promise<banStatus>;
  type: () => Promise<banType>;
  user: () => Promise<Int>;
  ip: () => Promise<String>;
  machine: () => Promise<String>;
  by: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BanPreviousValuesSubscription
  extends Promise<AsyncIterator<BanPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  reason: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<banStatus>>;
  type: () => Promise<AsyncIterator<banType>>;
  user: () => Promise<AsyncIterator<Int>>;
  ip: () => Promise<AsyncIterator<String>>;
  machine: () => Promise<AsyncIterator<String>>;
  by: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BotSubscriptionPayload {
  mutation: MutationType;
  node: Bot;
  updatedFields: String[];
  previousValues: BotPreviousValues;
}

export interface BotSubscriptionPayloadPromise
  extends Promise<BotSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BotPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BotPreviousValuesPromise>() => T;
}

export interface BotSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BotSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BotSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BotPreviousValuesSubscription>() => T;
}

export interface BotPreviousValues {
  id: ID_Output;
  name?: String;
  motto?: String;
  inventory?: Boolean;
  owner?: Int;
  gender?: Boolean;
  figure?: String;
  type?: String;
  state: String[];
  action: String[];
  position: Int[];
  messages?: String;
  chatBubble?: Int;
  chatAuto?: Int;
  chatRandom?: Boolean;
  chatDelay?: Int;
}

export interface BotPreviousValuesPromise
  extends Promise<BotPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  motto: () => Promise<String>;
  inventory: () => Promise<Boolean>;
  owner: () => Promise<Int>;
  gender: () => Promise<Boolean>;
  figure: () => Promise<String>;
  type: () => Promise<String>;
  state: () => Promise<String[]>;
  action: () => Promise<String[]>;
  position: () => Promise<Int[]>;
  messages: () => Promise<String>;
  chatBubble: () => Promise<Int>;
  chatAuto: () => Promise<Int>;
  chatRandom: () => Promise<Boolean>;
  chatDelay: () => Promise<Int>;
}

export interface BotPreviousValuesSubscription
  extends Promise<AsyncIterator<BotPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  motto: () => Promise<AsyncIterator<String>>;
  inventory: () => Promise<AsyncIterator<Boolean>>;
  owner: () => Promise<AsyncIterator<Int>>;
  gender: () => Promise<AsyncIterator<Boolean>>;
  figure: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String[]>>;
  action: () => Promise<AsyncIterator<String[]>>;
  position: () => Promise<AsyncIterator<Int[]>>;
  messages: () => Promise<AsyncIterator<String>>;
  chatBubble: () => Promise<AsyncIterator<Int>>;
  chatAuto: () => Promise<AsyncIterator<Int>>;
  chatRandom: () => Promise<AsyncIterator<Boolean>>;
  chatDelay: () => Promise<AsyncIterator<Int>>;
}

export interface CatalogItemSubscriptionPayload {
  mutation: MutationType;
  node: CatalogItem;
  updatedFields: String[];
  previousValues: CatalogItemPreviousValues;
}

export interface CatalogItemSubscriptionPayloadPromise
  extends Promise<CatalogItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CatalogItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CatalogItemPreviousValuesPromise>() => T;
}

export interface CatalogItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CatalogItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CatalogItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CatalogItemPreviousValuesSubscription>() => T;
}

export interface CatalogItemPreviousValues {
  id: ID_Output;
  page?: Int;
  item?: Int;
  name?: String;
  amount?: Int;
  limited?: Boolean;
  maximum?: Int;
  stack?: Boolean;
  active?: Boolean;
}

export interface CatalogItemPreviousValuesPromise
  extends Promise<CatalogItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  page: () => Promise<Int>;
  item: () => Promise<Int>;
  name: () => Promise<String>;
  amount: () => Promise<Int>;
  limited: () => Promise<Boolean>;
  maximum: () => Promise<Int>;
  stack: () => Promise<Boolean>;
  active: () => Promise<Boolean>;
}

export interface CatalogItemPreviousValuesSubscription
  extends Promise<AsyncIterator<CatalogItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  page: () => Promise<AsyncIterator<Int>>;
  item: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Int>>;
  limited: () => Promise<AsyncIterator<Boolean>>;
  maximum: () => Promise<AsyncIterator<Int>>;
  stack: () => Promise<AsyncIterator<Boolean>>;
  active: () => Promise<AsyncIterator<Boolean>>;
}

export interface CatalogPageSubscriptionPayload {
  mutation: MutationType;
  node: CatalogPage;
  updatedFields: String[];
  previousValues: CatalogPagePreviousValues;
}

export interface CatalogPageSubscriptionPayloadPromise
  extends Promise<CatalogPageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CatalogPagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CatalogPagePreviousValuesPromise>() => T;
}

export interface CatalogPageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CatalogPageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CatalogPageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CatalogPagePreviousValuesSubscription>() => T;
}

export interface CatalogPagePreviousValues {
  id: ID_Output;
  parent?: Int;
  type?: String;
  order?: Int;
  name: String;
  caption?: String;
  description?: String;
  icon?: String;
  visible?: Boolean;
  enabled?: Boolean;
  rank?: Int;
  club?: Boolean;
  vip?: Boolean;
  body?: String;
}

export interface CatalogPagePreviousValuesPromise
  extends Promise<CatalogPagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  parent: () => Promise<Int>;
  type: () => Promise<String>;
  order: () => Promise<Int>;
  name: () => Promise<String>;
  caption: () => Promise<String>;
  description: () => Promise<String>;
  icon: () => Promise<String>;
  visible: () => Promise<Boolean>;
  enabled: () => Promise<Boolean>;
  rank: () => Promise<Int>;
  club: () => Promise<Boolean>;
  vip: () => Promise<Boolean>;
  body: () => Promise<String>;
}

export interface CatalogPagePreviousValuesSubscription
  extends Promise<AsyncIterator<CatalogPagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parent: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  caption: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  icon: () => Promise<AsyncIterator<String>>;
  visible: () => Promise<AsyncIterator<Boolean>>;
  enabled: () => Promise<AsyncIterator<Boolean>>;
  rank: () => Promise<AsyncIterator<Int>>;
  club: () => Promise<AsyncIterator<Boolean>>;
  vip: () => Promise<AsyncIterator<Boolean>>;
  body: () => Promise<AsyncIterator<String>>;
}

export interface ItemSubscriptionPayload {
  mutation: MutationType;
  node: Item;
  updatedFields: String[];
  previousValues: ItemPreviousValues;
}

export interface ItemSubscriptionPayloadPromise
  extends Promise<ItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ItemPreviousValuesPromise>() => T;
}

export interface ItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ItemPreviousValuesSubscription>() => T;
}

export interface ItemPreviousValues {
  id: ID_Output;
  owner?: Int;
  furniture?: Int;
  type?: String;
  x?: Int;
  y?: Int;
  z?: Int;
  rotation?: Int;
  wallPosition: Float[];
  inventory?: Boolean;
}

export interface ItemPreviousValuesPromise
  extends Promise<ItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  owner: () => Promise<Int>;
  furniture: () => Promise<Int>;
  type: () => Promise<String>;
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  z: () => Promise<Int>;
  rotation: () => Promise<Int>;
  wallPosition: () => Promise<Float[]>;
  inventory: () => Promise<Boolean>;
}

export interface ItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  owner: () => Promise<AsyncIterator<Int>>;
  furniture: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
  x: () => Promise<AsyncIterator<Int>>;
  y: () => Promise<AsyncIterator<Int>>;
  z: () => Promise<AsyncIterator<Int>>;
  rotation: () => Promise<AsyncIterator<Int>>;
  wallPosition: () => Promise<AsyncIterator<Float[]>>;
  inventory: () => Promise<AsyncIterator<Boolean>>;
}

export interface RoomSubscriptionPayload {
  mutation: MutationType;
  node: Room;
  updatedFields: String[];
  previousValues: RoomPreviousValues;
}

export interface RoomSubscriptionPayloadPromise
  extends Promise<RoomSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RoomPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RoomPreviousValuesPromise>() => T;
}

export interface RoomSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RoomSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RoomSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RoomPreviousValuesSubscription>() => T;
}

export interface RoomPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  type?: roomType;
  category?: Int;
  owner?: Int;
  map?: Json;
  floorThickness?: Int;
  wallThickness?: Int;
  wallHeight?: Int;
  hideWalls?: Boolean;
  hideWired?: Boolean;
  maxUsers?: Int;
  allowPets?: Boolean;
  allowPetsEating?: Boolean;
  rights: Int[];
}

export interface RoomPreviousValuesPromise
  extends Promise<RoomPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  type: () => Promise<roomType>;
  category: () => Promise<Int>;
  owner: () => Promise<Int>;
  map: () => Promise<Json>;
  floorThickness: () => Promise<Int>;
  wallThickness: () => Promise<Int>;
  wallHeight: () => Promise<Int>;
  hideWalls: () => Promise<Boolean>;
  hideWired: () => Promise<Boolean>;
  maxUsers: () => Promise<Int>;
  allowPets: () => Promise<Boolean>;
  allowPetsEating: () => Promise<Boolean>;
  rights: () => Promise<Int[]>;
}

export interface RoomPreviousValuesSubscription
  extends Promise<AsyncIterator<RoomPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<roomType>>;
  category: () => Promise<AsyncIterator<Int>>;
  owner: () => Promise<AsyncIterator<Int>>;
  map: () => Promise<AsyncIterator<Json>>;
  floorThickness: () => Promise<AsyncIterator<Int>>;
  wallThickness: () => Promise<AsyncIterator<Int>>;
  wallHeight: () => Promise<AsyncIterator<Int>>;
  hideWalls: () => Promise<AsyncIterator<Boolean>>;
  hideWired: () => Promise<AsyncIterator<Boolean>>;
  maxUsers: () => Promise<AsyncIterator<Int>>;
  allowPets: () => Promise<AsyncIterator<Boolean>>;
  allowPetsEating: () => Promise<AsyncIterator<Boolean>>;
  rights: () => Promise<AsyncIterator<Int[]>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  username: String;
  email?: String;
  password?: String;
  pin?: Int;
  motto?: String;
  figure?: String;
  rank?: Int;
  vip?: Int;
  online?: Boolean;
  verified?: Int;
  home?: Int;
  volume?: Int;
  muted?: Boolean;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  pin: () => Promise<Int>;
  motto: () => Promise<String>;
  figure: () => Promise<String>;
  rank: () => Promise<Int>;
  vip: () => Promise<Int>;
  online: () => Promise<Boolean>;
  verified: () => Promise<Int>;
  home: () => Promise<Int>;
  volume: () => Promise<Int>;
  muted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  pin: () => Promise<AsyncIterator<Int>>;
  motto: () => Promise<AsyncIterator<String>>;
  figure: () => Promise<AsyncIterator<String>>;
  rank: () => Promise<AsyncIterator<Int>>;
  vip: () => Promise<AsyncIterator<Int>>;
  online: () => Promise<AsyncIterator<Boolean>>;
  verified: () => Promise<AsyncIterator<Int>>;
  home: () => Promise<AsyncIterator<Int>>;
  volume: () => Promise<AsyncIterator<Int>>;
  muted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Json = any;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "banType",
    embedded: false
  },
  {
    name: "banStatus",
    embedded: false
  },
  {
    name: "roomType",
    embedded: false
  },
  {
    name: "Ban",
    embedded: false
  },
  {
    name: "Badge",
    embedded: false
  },
  {
    name: "Bot",
    embedded: false
  },
  {
    name: "CatalogPage",
    embedded: false
  },
  {
    name: "CatalogItem",
    embedded: false
  },
  {
    name: "Room",
    embedded: false
  },
  {
    name: "Item",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
