module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.32.2). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateBadge {
  count: Int!
}

type AggregateBan {
  count: Int!
}

type AggregateBot {
  count: Int!
}

type AggregateCatalogItem {
  count: Int!
}

type AggregateCatalogPage {
  count: Int!
}

type AggregateItem {
  count: Int!
}

type AggregateRoom {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type Badge {
  id: ID!
  code: String!
  description: String
}

type BadgeConnection {
  pageInfo: PageInfo!
  edges: [BadgeEdge]!
  aggregate: AggregateBadge!
}

input BadgeCreateInput {
  id: ID
  code: String!
  description: String
}

type BadgeEdge {
  node: Badge!
  cursor: String!
}

enum BadgeOrderByInput {
  id_ASC
  id_DESC
  code_ASC
  code_DESC
  description_ASC
  description_DESC
}

type BadgePreviousValues {
  id: ID!
  code: String!
  description: String
}

type BadgeSubscriptionPayload {
  mutation: MutationType!
  node: Badge
  updatedFields: [String!]
  previousValues: BadgePreviousValues
}

input BadgeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BadgeWhereInput
  AND: [BadgeSubscriptionWhereInput!]
  OR: [BadgeSubscriptionWhereInput!]
  NOT: [BadgeSubscriptionWhereInput!]
}

input BadgeUpdateInput {
  code: String
  description: String
}

input BadgeUpdateManyMutationInput {
  code: String
  description: String
}

input BadgeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [BadgeWhereInput!]
  OR: [BadgeWhereInput!]
  NOT: [BadgeWhereInput!]
}

input BadgeWhereUniqueInput {
  id: ID
  code: String
}

type Ban {
  id: ID!
  reason: String
  status: banStatus
  type: banType
  user: Int
  ip: String
  machine: String
  by: Int
  createdAt: DateTime
  updatedAt: DateTime
}

type BanConnection {
  pageInfo: PageInfo!
  edges: [BanEdge]!
  aggregate: AggregateBan!
}

input BanCreateInput {
  id: ID
  reason: String
  status: banStatus
  type: banType
  user: Int
  ip: String
  machine: String
  by: Int
}

type BanEdge {
  node: Ban!
  cursor: String!
}

enum BanOrderByInput {
  id_ASC
  id_DESC
  reason_ASC
  reason_DESC
  status_ASC
  status_DESC
  type_ASC
  type_DESC
  user_ASC
  user_DESC
  ip_ASC
  ip_DESC
  machine_ASC
  machine_DESC
  by_ASC
  by_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BanPreviousValues {
  id: ID!
  reason: String
  status: banStatus
  type: banType
  user: Int
  ip: String
  machine: String
  by: Int
  createdAt: DateTime
  updatedAt: DateTime
}

enum banStatus {
  BANNED
  APPEALING
  REJECTED
}

type BanSubscriptionPayload {
  mutation: MutationType!
  node: Ban
  updatedFields: [String!]
  previousValues: BanPreviousValues
}

input BanSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BanWhereInput
  AND: [BanSubscriptionWhereInput!]
  OR: [BanSubscriptionWhereInput!]
  NOT: [BanSubscriptionWhereInput!]
}

enum banType {
  USER
  IP
  MACHINE
}

input BanUpdateInput {
  reason: String
  status: banStatus
  type: banType
  user: Int
  ip: String
  machine: String
  by: Int
}

input BanUpdateManyMutationInput {
  reason: String
  status: banStatus
  type: banType
  user: Int
  ip: String
  machine: String
  by: Int
}

input BanWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  reason: String
  reason_not: String
  reason_in: [String!]
  reason_not_in: [String!]
  reason_lt: String
  reason_lte: String
  reason_gt: String
  reason_gte: String
  reason_contains: String
  reason_not_contains: String
  reason_starts_with: String
  reason_not_starts_with: String
  reason_ends_with: String
  reason_not_ends_with: String
  status: banStatus
  status_not: banStatus
  status_in: [banStatus!]
  status_not_in: [banStatus!]
  type: banType
  type_not: banType
  type_in: [banType!]
  type_not_in: [banType!]
  user: Int
  user_not: Int
  user_in: [Int!]
  user_not_in: [Int!]
  user_lt: Int
  user_lte: Int
  user_gt: Int
  user_gte: Int
  ip: String
  ip_not: String
  ip_in: [String!]
  ip_not_in: [String!]
  ip_lt: String
  ip_lte: String
  ip_gt: String
  ip_gte: String
  ip_contains: String
  ip_not_contains: String
  ip_starts_with: String
  ip_not_starts_with: String
  ip_ends_with: String
  ip_not_ends_with: String
  machine: String
  machine_not: String
  machine_in: [String!]
  machine_not_in: [String!]
  machine_lt: String
  machine_lte: String
  machine_gt: String
  machine_gte: String
  machine_contains: String
  machine_not_contains: String
  machine_starts_with: String
  machine_not_starts_with: String
  machine_ends_with: String
  machine_not_ends_with: String
  by: Int
  by_not: Int
  by_in: [Int!]
  by_not_in: [Int!]
  by_lt: Int
  by_lte: Int
  by_gt: Int
  by_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [BanWhereInput!]
  OR: [BanWhereInput!]
  NOT: [BanWhereInput!]
}

input BanWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Bot {
  id: ID!
  name: String
  motto: String
  inventory: Boolean
  owner: Int
  gender: Boolean
  figure: String
  type: String
  state: [String!]!
  action: [String!]!
  position: [Int!]!
  messages: String
  chatBubble: Int
  chatAuto: Int
  chatRandom: Boolean
  chatDelay: Int
}

type BotConnection {
  pageInfo: PageInfo!
  edges: [BotEdge]!
  aggregate: AggregateBot!
}

input BotCreateactionInput {
  set: [String!]
}

input BotCreateInput {
  id: ID
  name: String
  motto: String
  inventory: Boolean
  owner: Int
  gender: Boolean
  figure: String
  type: String
  state: BotCreatestateInput
  action: BotCreateactionInput
  position: BotCreatepositionInput
  messages: String
  chatBubble: Int
  chatAuto: Int
  chatRandom: Boolean
  chatDelay: Int
}

input BotCreatepositionInput {
  set: [Int!]
}

input BotCreatestateInput {
  set: [String!]
}

type BotEdge {
  node: Bot!
  cursor: String!
}

enum BotOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  motto_ASC
  motto_DESC
  inventory_ASC
  inventory_DESC
  owner_ASC
  owner_DESC
  gender_ASC
  gender_DESC
  figure_ASC
  figure_DESC
  type_ASC
  type_DESC
  messages_ASC
  messages_DESC
  chatBubble_ASC
  chatBubble_DESC
  chatAuto_ASC
  chatAuto_DESC
  chatRandom_ASC
  chatRandom_DESC
  chatDelay_ASC
  chatDelay_DESC
}

type BotPreviousValues {
  id: ID!
  name: String
  motto: String
  inventory: Boolean
  owner: Int
  gender: Boolean
  figure: String
  type: String
  state: [String!]!
  action: [String!]!
  position: [Int!]!
  messages: String
  chatBubble: Int
  chatAuto: Int
  chatRandom: Boolean
  chatDelay: Int
}

type BotSubscriptionPayload {
  mutation: MutationType!
  node: Bot
  updatedFields: [String!]
  previousValues: BotPreviousValues
}

input BotSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BotWhereInput
  AND: [BotSubscriptionWhereInput!]
  OR: [BotSubscriptionWhereInput!]
  NOT: [BotSubscriptionWhereInput!]
}

input BotUpdateactionInput {
  set: [String!]
}

input BotUpdateInput {
  name: String
  motto: String
  inventory: Boolean
  owner: Int
  gender: Boolean
  figure: String
  type: String
  state: BotUpdatestateInput
  action: BotUpdateactionInput
  position: BotUpdatepositionInput
  messages: String
  chatBubble: Int
  chatAuto: Int
  chatRandom: Boolean
  chatDelay: Int
}

input BotUpdateManyMutationInput {
  name: String
  motto: String
  inventory: Boolean
  owner: Int
  gender: Boolean
  figure: String
  type: String
  state: BotUpdatestateInput
  action: BotUpdateactionInput
  position: BotUpdatepositionInput
  messages: String
  chatBubble: Int
  chatAuto: Int
  chatRandom: Boolean
  chatDelay: Int
}

input BotUpdatepositionInput {
  set: [Int!]
}

input BotUpdatestateInput {
  set: [String!]
}

input BotWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  motto: String
  motto_not: String
  motto_in: [String!]
  motto_not_in: [String!]
  motto_lt: String
  motto_lte: String
  motto_gt: String
  motto_gte: String
  motto_contains: String
  motto_not_contains: String
  motto_starts_with: String
  motto_not_starts_with: String
  motto_ends_with: String
  motto_not_ends_with: String
  inventory: Boolean
  inventory_not: Boolean
  owner: Int
  owner_not: Int
  owner_in: [Int!]
  owner_not_in: [Int!]
  owner_lt: Int
  owner_lte: Int
  owner_gt: Int
  owner_gte: Int
  gender: Boolean
  gender_not: Boolean
  figure: String
  figure_not: String
  figure_in: [String!]
  figure_not_in: [String!]
  figure_lt: String
  figure_lte: String
  figure_gt: String
  figure_gte: String
  figure_contains: String
  figure_not_contains: String
  figure_starts_with: String
  figure_not_starts_with: String
  figure_ends_with: String
  figure_not_ends_with: String
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  messages: String
  messages_not: String
  messages_in: [String!]
  messages_not_in: [String!]
  messages_lt: String
  messages_lte: String
  messages_gt: String
  messages_gte: String
  messages_contains: String
  messages_not_contains: String
  messages_starts_with: String
  messages_not_starts_with: String
  messages_ends_with: String
  messages_not_ends_with: String
  chatBubble: Int
  chatBubble_not: Int
  chatBubble_in: [Int!]
  chatBubble_not_in: [Int!]
  chatBubble_lt: Int
  chatBubble_lte: Int
  chatBubble_gt: Int
  chatBubble_gte: Int
  chatAuto: Int
  chatAuto_not: Int
  chatAuto_in: [Int!]
  chatAuto_not_in: [Int!]
  chatAuto_lt: Int
  chatAuto_lte: Int
  chatAuto_gt: Int
  chatAuto_gte: Int
  chatRandom: Boolean
  chatRandom_not: Boolean
  chatDelay: Int
  chatDelay_not: Int
  chatDelay_in: [Int!]
  chatDelay_not_in: [Int!]
  chatDelay_lt: Int
  chatDelay_lte: Int
  chatDelay_gt: Int
  chatDelay_gte: Int
  AND: [BotWhereInput!]
  OR: [BotWhereInput!]
  NOT: [BotWhereInput!]
}

input BotWhereUniqueInput {
  id: ID
}

type CatalogItem {
  id: ID!
  page: Int
  item: Int
  name: String
  amount: Int
  limited: Boolean
  maximum: Int
  stack: Boolean
  active: Boolean
}

type CatalogItemConnection {
  pageInfo: PageInfo!
  edges: [CatalogItemEdge]!
  aggregate: AggregateCatalogItem!
}

input CatalogItemCreateInput {
  id: ID
  page: Int
  item: Int
  name: String
  amount: Int
  limited: Boolean
  maximum: Int
  stack: Boolean
  active: Boolean
}

type CatalogItemEdge {
  node: CatalogItem!
  cursor: String!
}

enum CatalogItemOrderByInput {
  id_ASC
  id_DESC
  page_ASC
  page_DESC
  item_ASC
  item_DESC
  name_ASC
  name_DESC
  amount_ASC
  amount_DESC
  limited_ASC
  limited_DESC
  maximum_ASC
  maximum_DESC
  stack_ASC
  stack_DESC
  active_ASC
  active_DESC
}

type CatalogItemPreviousValues {
  id: ID!
  page: Int
  item: Int
  name: String
  amount: Int
  limited: Boolean
  maximum: Int
  stack: Boolean
  active: Boolean
}

type CatalogItemSubscriptionPayload {
  mutation: MutationType!
  node: CatalogItem
  updatedFields: [String!]
  previousValues: CatalogItemPreviousValues
}

input CatalogItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CatalogItemWhereInput
  AND: [CatalogItemSubscriptionWhereInput!]
  OR: [CatalogItemSubscriptionWhereInput!]
  NOT: [CatalogItemSubscriptionWhereInput!]
}

input CatalogItemUpdateInput {
  page: Int
  item: Int
  name: String
  amount: Int
  limited: Boolean
  maximum: Int
  stack: Boolean
  active: Boolean
}

input CatalogItemUpdateManyMutationInput {
  page: Int
  item: Int
  name: String
  amount: Int
  limited: Boolean
  maximum: Int
  stack: Boolean
  active: Boolean
}

input CatalogItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  page: Int
  page_not: Int
  page_in: [Int!]
  page_not_in: [Int!]
  page_lt: Int
  page_lte: Int
  page_gt: Int
  page_gte: Int
  item: Int
  item_not: Int
  item_in: [Int!]
  item_not_in: [Int!]
  item_lt: Int
  item_lte: Int
  item_gt: Int
  item_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  limited: Boolean
  limited_not: Boolean
  maximum: Int
  maximum_not: Int
  maximum_in: [Int!]
  maximum_not_in: [Int!]
  maximum_lt: Int
  maximum_lte: Int
  maximum_gt: Int
  maximum_gte: Int
  stack: Boolean
  stack_not: Boolean
  active: Boolean
  active_not: Boolean
  AND: [CatalogItemWhereInput!]
  OR: [CatalogItemWhereInput!]
  NOT: [CatalogItemWhereInput!]
}

input CatalogItemWhereUniqueInput {
  id: ID
}

type CatalogPage {
  id: ID!
  parent: Int
  type: String
  order: Int
  name: String!
  caption: String
  description: String
  icon: String
  visible: Boolean
  enabled: Boolean
  rank: Int
  club: Boolean
  vip: Boolean
  body: String
}

type CatalogPageConnection {
  pageInfo: PageInfo!
  edges: [CatalogPageEdge]!
  aggregate: AggregateCatalogPage!
}

input CatalogPageCreateInput {
  id: ID
  parent: Int
  type: String
  order: Int
  name: String!
  caption: String
  description: String
  icon: String
  visible: Boolean
  enabled: Boolean
  rank: Int
  club: Boolean
  vip: Boolean
  body: String
}

type CatalogPageEdge {
  node: CatalogPage!
  cursor: String!
}

enum CatalogPageOrderByInput {
  id_ASC
  id_DESC
  parent_ASC
  parent_DESC
  type_ASC
  type_DESC
  order_ASC
  order_DESC
  name_ASC
  name_DESC
  caption_ASC
  caption_DESC
  description_ASC
  description_DESC
  icon_ASC
  icon_DESC
  visible_ASC
  visible_DESC
  enabled_ASC
  enabled_DESC
  rank_ASC
  rank_DESC
  club_ASC
  club_DESC
  vip_ASC
  vip_DESC
  body_ASC
  body_DESC
}

type CatalogPagePreviousValues {
  id: ID!
  parent: Int
  type: String
  order: Int
  name: String!
  caption: String
  description: String
  icon: String
  visible: Boolean
  enabled: Boolean
  rank: Int
  club: Boolean
  vip: Boolean
  body: String
}

type CatalogPageSubscriptionPayload {
  mutation: MutationType!
  node: CatalogPage
  updatedFields: [String!]
  previousValues: CatalogPagePreviousValues
}

input CatalogPageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CatalogPageWhereInput
  AND: [CatalogPageSubscriptionWhereInput!]
  OR: [CatalogPageSubscriptionWhereInput!]
  NOT: [CatalogPageSubscriptionWhereInput!]
}

input CatalogPageUpdateInput {
  parent: Int
  type: String
  order: Int
  name: String
  caption: String
  description: String
  icon: String
  visible: Boolean
  enabled: Boolean
  rank: Int
  club: Boolean
  vip: Boolean
  body: String
}

input CatalogPageUpdateManyMutationInput {
  parent: Int
  type: String
  order: Int
  name: String
  caption: String
  description: String
  icon: String
  visible: Boolean
  enabled: Boolean
  rank: Int
  club: Boolean
  vip: Boolean
  body: String
}

input CatalogPageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  parent: Int
  parent_not: Int
  parent_in: [Int!]
  parent_not_in: [Int!]
  parent_lt: Int
  parent_lte: Int
  parent_gt: Int
  parent_gte: Int
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  caption: String
  caption_not: String
  caption_in: [String!]
  caption_not_in: [String!]
  caption_lt: String
  caption_lte: String
  caption_gt: String
  caption_gte: String
  caption_contains: String
  caption_not_contains: String
  caption_starts_with: String
  caption_not_starts_with: String
  caption_ends_with: String
  caption_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  icon: String
  icon_not: String
  icon_in: [String!]
  icon_not_in: [String!]
  icon_lt: String
  icon_lte: String
  icon_gt: String
  icon_gte: String
  icon_contains: String
  icon_not_contains: String
  icon_starts_with: String
  icon_not_starts_with: String
  icon_ends_with: String
  icon_not_ends_with: String
  visible: Boolean
  visible_not: Boolean
  enabled: Boolean
  enabled_not: Boolean
  rank: Int
  rank_not: Int
  rank_in: [Int!]
  rank_not_in: [Int!]
  rank_lt: Int
  rank_lte: Int
  rank_gt: Int
  rank_gte: Int
  club: Boolean
  club_not: Boolean
  vip: Boolean
  vip_not: Boolean
  body: String
  body_not: String
  body_in: [String!]
  body_not_in: [String!]
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  AND: [CatalogPageWhereInput!]
  OR: [CatalogPageWhereInput!]
  NOT: [CatalogPageWhereInput!]
}

input CatalogPageWhereUniqueInput {
  id: ID
}

scalar DateTime

type Item {
  id: ID!
  owner: Int
  room: Room!
  furniture: Int
  type: String
  x: Int
  y: Int
  z: Int
  rotation: Int
  wallPosition: [Float!]!
  inventory: Boolean
}

type ItemConnection {
  pageInfo: PageInfo!
  edges: [ItemEdge]!
  aggregate: AggregateItem!
}

input ItemCreateInput {
  id: ID
  owner: Int
  room: RoomCreateOneWithoutItemsInput!
  furniture: Int
  type: String
  x: Int
  y: Int
  z: Int
  rotation: Int
  wallPosition: ItemCreatewallPositionInput
  inventory: Boolean
}

input ItemCreateManyWithoutRoomInput {
  create: [ItemCreateWithoutRoomInput!]
  connect: [ItemWhereUniqueInput!]
}

input ItemCreatewallPositionInput {
  set: [Float!]
}

input ItemCreateWithoutRoomInput {
  id: ID
  owner: Int
  furniture: Int
  type: String
  x: Int
  y: Int
  z: Int
  rotation: Int
  wallPosition: ItemCreatewallPositionInput
  inventory: Boolean
}

type ItemEdge {
  node: Item!
  cursor: String!
}

enum ItemOrderByInput {
  id_ASC
  id_DESC
  owner_ASC
  owner_DESC
  furniture_ASC
  furniture_DESC
  type_ASC
  type_DESC
  x_ASC
  x_DESC
  y_ASC
  y_DESC
  z_ASC
  z_DESC
  rotation_ASC
  rotation_DESC
  inventory_ASC
  inventory_DESC
}

type ItemPreviousValues {
  id: ID!
  owner: Int
  furniture: Int
  type: String
  x: Int
  y: Int
  z: Int
  rotation: Int
  wallPosition: [Float!]!
  inventory: Boolean
}

input ItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  owner: Int
  owner_not: Int
  owner_in: [Int!]
  owner_not_in: [Int!]
  owner_lt: Int
  owner_lte: Int
  owner_gt: Int
  owner_gte: Int
  furniture: Int
  furniture_not: Int
  furniture_in: [Int!]
  furniture_not_in: [Int!]
  furniture_lt: Int
  furniture_lte: Int
  furniture_gt: Int
  furniture_gte: Int
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  x: Int
  x_not: Int
  x_in: [Int!]
  x_not_in: [Int!]
  x_lt: Int
  x_lte: Int
  x_gt: Int
  x_gte: Int
  y: Int
  y_not: Int
  y_in: [Int!]
  y_not_in: [Int!]
  y_lt: Int
  y_lte: Int
  y_gt: Int
  y_gte: Int
  z: Int
  z_not: Int
  z_in: [Int!]
  z_not_in: [Int!]
  z_lt: Int
  z_lte: Int
  z_gt: Int
  z_gte: Int
  rotation: Int
  rotation_not: Int
  rotation_in: [Int!]
  rotation_not_in: [Int!]
  rotation_lt: Int
  rotation_lte: Int
  rotation_gt: Int
  rotation_gte: Int
  inventory: Boolean
  inventory_not: Boolean
  AND: [ItemScalarWhereInput!]
  OR: [ItemScalarWhereInput!]
  NOT: [ItemScalarWhereInput!]
}

type ItemSubscriptionPayload {
  mutation: MutationType!
  node: Item
  updatedFields: [String!]
  previousValues: ItemPreviousValues
}

input ItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ItemWhereInput
  AND: [ItemSubscriptionWhereInput!]
  OR: [ItemSubscriptionWhereInput!]
  NOT: [ItemSubscriptionWhereInput!]
}

input ItemUpdateInput {
  owner: Int
  room: RoomUpdateOneRequiredWithoutItemsInput
  furniture: Int
  type: String
  x: Int
  y: Int
  z: Int
  rotation: Int
  wallPosition: ItemUpdatewallPositionInput
  inventory: Boolean
}

input ItemUpdateManyDataInput {
  owner: Int
  furniture: Int
  type: String
  x: Int
  y: Int
  z: Int
  rotation: Int
  wallPosition: ItemUpdatewallPositionInput
  inventory: Boolean
}

input ItemUpdateManyMutationInput {
  owner: Int
  furniture: Int
  type: String
  x: Int
  y: Int
  z: Int
  rotation: Int
  wallPosition: ItemUpdatewallPositionInput
  inventory: Boolean
}

input ItemUpdateManyWithoutRoomInput {
  create: [ItemCreateWithoutRoomInput!]
  delete: [ItemWhereUniqueInput!]
  connect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  disconnect: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutRoomInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutRoomInput!]
  deleteMany: [ItemScalarWhereInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
}

input ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput!
  data: ItemUpdateManyDataInput!
}

input ItemUpdatewallPositionInput {
  set: [Float!]
}

input ItemUpdateWithoutRoomDataInput {
  owner: Int
  furniture: Int
  type: String
  x: Int
  y: Int
  z: Int
  rotation: Int
  wallPosition: ItemUpdatewallPositionInput
  inventory: Boolean
}

input ItemUpdateWithWhereUniqueWithoutRoomInput {
  where: ItemWhereUniqueInput!
  data: ItemUpdateWithoutRoomDataInput!
}

input ItemUpsertWithWhereUniqueWithoutRoomInput {
  where: ItemWhereUniqueInput!
  update: ItemUpdateWithoutRoomDataInput!
  create: ItemCreateWithoutRoomInput!
}

input ItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  owner: Int
  owner_not: Int
  owner_in: [Int!]
  owner_not_in: [Int!]
  owner_lt: Int
  owner_lte: Int
  owner_gt: Int
  owner_gte: Int
  room: RoomWhereInput
  furniture: Int
  furniture_not: Int
  furniture_in: [Int!]
  furniture_not_in: [Int!]
  furniture_lt: Int
  furniture_lte: Int
  furniture_gt: Int
  furniture_gte: Int
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  x: Int
  x_not: Int
  x_in: [Int!]
  x_not_in: [Int!]
  x_lt: Int
  x_lte: Int
  x_gt: Int
  x_gte: Int
  y: Int
  y_not: Int
  y_in: [Int!]
  y_not_in: [Int!]
  y_lt: Int
  y_lte: Int
  y_gt: Int
  y_gte: Int
  z: Int
  z_not: Int
  z_in: [Int!]
  z_not_in: [Int!]
  z_lt: Int
  z_lte: Int
  z_gt: Int
  z_gte: Int
  rotation: Int
  rotation_not: Int
  rotation_in: [Int!]
  rotation_not_in: [Int!]
  rotation_lt: Int
  rotation_lte: Int
  rotation_gt: Int
  rotation_gte: Int
  inventory: Boolean
  inventory_not: Boolean
  AND: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  NOT: [ItemWhereInput!]
}

input ItemWhereUniqueInput {
  id: ID
}

scalar Json

scalar Long

type Mutation {
  createBadge(data: BadgeCreateInput!): Badge!
  updateBadge(data: BadgeUpdateInput!, where: BadgeWhereUniqueInput!): Badge
  updateManyBadges(data: BadgeUpdateManyMutationInput!, where: BadgeWhereInput): BatchPayload!
  upsertBadge(where: BadgeWhereUniqueInput!, create: BadgeCreateInput!, update: BadgeUpdateInput!): Badge!
  deleteBadge(where: BadgeWhereUniqueInput!): Badge
  deleteManyBadges(where: BadgeWhereInput): BatchPayload!
  createBan(data: BanCreateInput!): Ban!
  updateBan(data: BanUpdateInput!, where: BanWhereUniqueInput!): Ban
  updateManyBans(data: BanUpdateManyMutationInput!, where: BanWhereInput): BatchPayload!
  upsertBan(where: BanWhereUniqueInput!, create: BanCreateInput!, update: BanUpdateInput!): Ban!
  deleteBan(where: BanWhereUniqueInput!): Ban
  deleteManyBans(where: BanWhereInput): BatchPayload!
  createBot(data: BotCreateInput!): Bot!
  updateBot(data: BotUpdateInput!, where: BotWhereUniqueInput!): Bot
  updateManyBots(data: BotUpdateManyMutationInput!, where: BotWhereInput): BatchPayload!
  upsertBot(where: BotWhereUniqueInput!, create: BotCreateInput!, update: BotUpdateInput!): Bot!
  deleteBot(where: BotWhereUniqueInput!): Bot
  deleteManyBots(where: BotWhereInput): BatchPayload!
  createCatalogItem(data: CatalogItemCreateInput!): CatalogItem!
  updateCatalogItem(data: CatalogItemUpdateInput!, where: CatalogItemWhereUniqueInput!): CatalogItem
  updateManyCatalogItems(data: CatalogItemUpdateManyMutationInput!, where: CatalogItemWhereInput): BatchPayload!
  upsertCatalogItem(where: CatalogItemWhereUniqueInput!, create: CatalogItemCreateInput!, update: CatalogItemUpdateInput!): CatalogItem!
  deleteCatalogItem(where: CatalogItemWhereUniqueInput!): CatalogItem
  deleteManyCatalogItems(where: CatalogItemWhereInput): BatchPayload!
  createCatalogPage(data: CatalogPageCreateInput!): CatalogPage!
  updateCatalogPage(data: CatalogPageUpdateInput!, where: CatalogPageWhereUniqueInput!): CatalogPage
  updateManyCatalogPages(data: CatalogPageUpdateManyMutationInput!, where: CatalogPageWhereInput): BatchPayload!
  upsertCatalogPage(where: CatalogPageWhereUniqueInput!, create: CatalogPageCreateInput!, update: CatalogPageUpdateInput!): CatalogPage!
  deleteCatalogPage(where: CatalogPageWhereUniqueInput!): CatalogPage
  deleteManyCatalogPages(where: CatalogPageWhereInput): BatchPayload!
  createItem(data: ItemCreateInput!): Item!
  updateItem(data: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item
  updateManyItems(data: ItemUpdateManyMutationInput!, where: ItemWhereInput): BatchPayload!
  upsertItem(where: ItemWhereUniqueInput!, create: ItemCreateInput!, update: ItemUpdateInput!): Item!
  deleteItem(where: ItemWhereUniqueInput!): Item
  deleteManyItems(where: ItemWhereInput): BatchPayload!
  createRoom(data: RoomCreateInput!): Room!
  updateRoom(data: RoomUpdateInput!, where: RoomWhereUniqueInput!): Room
  updateManyRooms(data: RoomUpdateManyMutationInput!, where: RoomWhereInput): BatchPayload!
  upsertRoom(where: RoomWhereUniqueInput!, create: RoomCreateInput!, update: RoomUpdateInput!): Room!
  deleteRoom(where: RoomWhereUniqueInput!): Room
  deleteManyRooms(where: RoomWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  badge(where: BadgeWhereUniqueInput!): Badge
  badges(where: BadgeWhereInput, orderBy: BadgeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Badge]!
  badgesConnection(where: BadgeWhereInput, orderBy: BadgeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BadgeConnection!
  ban(where: BanWhereUniqueInput!): Ban
  bans(where: BanWhereInput, orderBy: BanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ban]!
  bansConnection(where: BanWhereInput, orderBy: BanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BanConnection!
  bot(where: BotWhereUniqueInput!): Bot
  bots(where: BotWhereInput, orderBy: BotOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Bot]!
  botsConnection(where: BotWhereInput, orderBy: BotOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BotConnection!
  catalogItem(where: CatalogItemWhereUniqueInput!): CatalogItem
  catalogItems(where: CatalogItemWhereInput, orderBy: CatalogItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CatalogItem]!
  catalogItemsConnection(where: CatalogItemWhereInput, orderBy: CatalogItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CatalogItemConnection!
  catalogPage(where: CatalogPageWhereUniqueInput!): CatalogPage
  catalogPages(where: CatalogPageWhereInput, orderBy: CatalogPageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CatalogPage]!
  catalogPagesConnection(where: CatalogPageWhereInput, orderBy: CatalogPageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CatalogPageConnection!
  item(where: ItemWhereUniqueInput!): Item
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item]!
  itemsConnection(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ItemConnection!
  room(where: RoomWhereUniqueInput!): Room
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room]!
  roomsConnection(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoomConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Room {
  id: ID!
  name: String!
  description: String
  type: roomType
  category: Int
  owner: Int
  map: Json
  floorThickness: Int
  wallThickness: Int
  wallHeight: Int
  hideWalls: Boolean
  hideWired: Boolean
  maxUsers: Int
  allowPets: Boolean
  allowPetsEating: Boolean
  rights: [Int!]!
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item!]
}

type RoomConnection {
  pageInfo: PageInfo!
  edges: [RoomEdge]!
  aggregate: AggregateRoom!
}

input RoomCreateInput {
  id: ID
  name: String!
  description: String
  type: roomType
  category: Int
  owner: Int
  map: Json
  floorThickness: Int
  wallThickness: Int
  wallHeight: Int
  hideWalls: Boolean
  hideWired: Boolean
  maxUsers: Int
  allowPets: Boolean
  allowPetsEating: Boolean
  rights: RoomCreaterightsInput
  items: ItemCreateManyWithoutRoomInput
}

input RoomCreateOneWithoutItemsInput {
  create: RoomCreateWithoutItemsInput
  connect: RoomWhereUniqueInput
}

input RoomCreaterightsInput {
  set: [Int!]
}

input RoomCreateWithoutItemsInput {
  id: ID
  name: String!
  description: String
  type: roomType
  category: Int
  owner: Int
  map: Json
  floorThickness: Int
  wallThickness: Int
  wallHeight: Int
  hideWalls: Boolean
  hideWired: Boolean
  maxUsers: Int
  allowPets: Boolean
  allowPetsEating: Boolean
  rights: RoomCreaterightsInput
}

type RoomEdge {
  node: Room!
  cursor: String!
}

enum RoomOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  type_ASC
  type_DESC
  category_ASC
  category_DESC
  owner_ASC
  owner_DESC
  map_ASC
  map_DESC
  floorThickness_ASC
  floorThickness_DESC
  wallThickness_ASC
  wallThickness_DESC
  wallHeight_ASC
  wallHeight_DESC
  hideWalls_ASC
  hideWalls_DESC
  hideWired_ASC
  hideWired_DESC
  maxUsers_ASC
  maxUsers_DESC
  allowPets_ASC
  allowPets_DESC
  allowPetsEating_ASC
  allowPetsEating_DESC
}

type RoomPreviousValues {
  id: ID!
  name: String!
  description: String
  type: roomType
  category: Int
  owner: Int
  map: Json
  floorThickness: Int
  wallThickness: Int
  wallHeight: Int
  hideWalls: Boolean
  hideWired: Boolean
  maxUsers: Int
  allowPets: Boolean
  allowPetsEating: Boolean
  rights: [Int!]!
}

type RoomSubscriptionPayload {
  mutation: MutationType!
  node: Room
  updatedFields: [String!]
  previousValues: RoomPreviousValues
}

input RoomSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoomWhereInput
  AND: [RoomSubscriptionWhereInput!]
  OR: [RoomSubscriptionWhereInput!]
  NOT: [RoomSubscriptionWhereInput!]
}

enum roomType {
  PUBLIC
  LOCKED
  PASSWORD
  HIDDEN
}

input RoomUpdateInput {
  name: String
  description: String
  type: roomType
  category: Int
  owner: Int
  map: Json
  floorThickness: Int
  wallThickness: Int
  wallHeight: Int
  hideWalls: Boolean
  hideWired: Boolean
  maxUsers: Int
  allowPets: Boolean
  allowPetsEating: Boolean
  rights: RoomUpdaterightsInput
  items: ItemUpdateManyWithoutRoomInput
}

input RoomUpdateManyMutationInput {
  name: String
  description: String
  type: roomType
  category: Int
  owner: Int
  map: Json
  floorThickness: Int
  wallThickness: Int
  wallHeight: Int
  hideWalls: Boolean
  hideWired: Boolean
  maxUsers: Int
  allowPets: Boolean
  allowPetsEating: Boolean
  rights: RoomUpdaterightsInput
}

input RoomUpdateOneRequiredWithoutItemsInput {
  create: RoomCreateWithoutItemsInput
  update: RoomUpdateWithoutItemsDataInput
  upsert: RoomUpsertWithoutItemsInput
  connect: RoomWhereUniqueInput
}

input RoomUpdaterightsInput {
  set: [Int!]
}

input RoomUpdateWithoutItemsDataInput {
  name: String
  description: String
  type: roomType
  category: Int
  owner: Int
  map: Json
  floorThickness: Int
  wallThickness: Int
  wallHeight: Int
  hideWalls: Boolean
  hideWired: Boolean
  maxUsers: Int
  allowPets: Boolean
  allowPetsEating: Boolean
  rights: RoomUpdaterightsInput
}

input RoomUpsertWithoutItemsInput {
  update: RoomUpdateWithoutItemsDataInput!
  create: RoomCreateWithoutItemsInput!
}

input RoomWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  type: roomType
  type_not: roomType
  type_in: [roomType!]
  type_not_in: [roomType!]
  category: Int
  category_not: Int
  category_in: [Int!]
  category_not_in: [Int!]
  category_lt: Int
  category_lte: Int
  category_gt: Int
  category_gte: Int
  owner: Int
  owner_not: Int
  owner_in: [Int!]
  owner_not_in: [Int!]
  owner_lt: Int
  owner_lte: Int
  owner_gt: Int
  owner_gte: Int
  floorThickness: Int
  floorThickness_not: Int
  floorThickness_in: [Int!]
  floorThickness_not_in: [Int!]
  floorThickness_lt: Int
  floorThickness_lte: Int
  floorThickness_gt: Int
  floorThickness_gte: Int
  wallThickness: Int
  wallThickness_not: Int
  wallThickness_in: [Int!]
  wallThickness_not_in: [Int!]
  wallThickness_lt: Int
  wallThickness_lte: Int
  wallThickness_gt: Int
  wallThickness_gte: Int
  wallHeight: Int
  wallHeight_not: Int
  wallHeight_in: [Int!]
  wallHeight_not_in: [Int!]
  wallHeight_lt: Int
  wallHeight_lte: Int
  wallHeight_gt: Int
  wallHeight_gte: Int
  hideWalls: Boolean
  hideWalls_not: Boolean
  hideWired: Boolean
  hideWired_not: Boolean
  maxUsers: Int
  maxUsers_not: Int
  maxUsers_in: [Int!]
  maxUsers_not_in: [Int!]
  maxUsers_lt: Int
  maxUsers_lte: Int
  maxUsers_gt: Int
  maxUsers_gte: Int
  allowPets: Boolean
  allowPets_not: Boolean
  allowPetsEating: Boolean
  allowPetsEating_not: Boolean
  items_every: ItemWhereInput
  items_some: ItemWhereInput
  items_none: ItemWhereInput
  AND: [RoomWhereInput!]
  OR: [RoomWhereInput!]
  NOT: [RoomWhereInput!]
}

input RoomWhereUniqueInput {
  id: ID
}

type Subscription {
  badge(where: BadgeSubscriptionWhereInput): BadgeSubscriptionPayload
  ban(where: BanSubscriptionWhereInput): BanSubscriptionPayload
  bot(where: BotSubscriptionWhereInput): BotSubscriptionPayload
  catalogItem(where: CatalogItemSubscriptionWhereInput): CatalogItemSubscriptionPayload
  catalogPage(where: CatalogPageSubscriptionWhereInput): CatalogPageSubscriptionPayload
  item(where: ItemSubscriptionWhereInput): ItemSubscriptionPayload
  room(where: RoomSubscriptionWhereInput): RoomSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  username: String!
  email: String
  password: String
  pin: Int
  motto: String
  figure: String
  rank: Int
  vip: Int
  online: Boolean
  verified: Int
  home: Int
  volume: Int
  muted: Boolean
  createdAt: DateTime
  updatedAt: DateTime
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  username: String!
  email: String
  password: String
  pin: Int
  motto: String
  figure: String
  rank: Int
  vip: Int
  online: Boolean
  verified: Int
  home: Int
  volume: Int
  muted: Boolean
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  username_ASC
  username_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  pin_ASC
  pin_DESC
  motto_ASC
  motto_DESC
  figure_ASC
  figure_DESC
  rank_ASC
  rank_DESC
  vip_ASC
  vip_DESC
  online_ASC
  online_DESC
  verified_ASC
  verified_DESC
  home_ASC
  home_DESC
  volume_ASC
  volume_DESC
  muted_ASC
  muted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  username: String!
  email: String
  password: String
  pin: Int
  motto: String
  figure: String
  rank: Int
  vip: Int
  online: Boolean
  verified: Int
  home: Int
  volume: Int
  muted: Boolean
  createdAt: DateTime
  updatedAt: DateTime
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  username: String
  email: String
  password: String
  pin: Int
  motto: String
  figure: String
  rank: Int
  vip: Int
  online: Boolean
  verified: Int
  home: Int
  volume: Int
  muted: Boolean
}

input UserUpdateManyMutationInput {
  username: String
  email: String
  password: String
  pin: Int
  motto: String
  figure: String
  rank: Int
  vip: Int
  online: Boolean
  verified: Int
  home: Int
  volume: Int
  muted: Boolean
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  pin: Int
  pin_not: Int
  pin_in: [Int!]
  pin_not_in: [Int!]
  pin_lt: Int
  pin_lte: Int
  pin_gt: Int
  pin_gte: Int
  motto: String
  motto_not: String
  motto_in: [String!]
  motto_not_in: [String!]
  motto_lt: String
  motto_lte: String
  motto_gt: String
  motto_gte: String
  motto_contains: String
  motto_not_contains: String
  motto_starts_with: String
  motto_not_starts_with: String
  motto_ends_with: String
  motto_not_ends_with: String
  figure: String
  figure_not: String
  figure_in: [String!]
  figure_not_in: [String!]
  figure_lt: String
  figure_lte: String
  figure_gt: String
  figure_gte: String
  figure_contains: String
  figure_not_contains: String
  figure_starts_with: String
  figure_not_starts_with: String
  figure_ends_with: String
  figure_not_ends_with: String
  rank: Int
  rank_not: Int
  rank_in: [Int!]
  rank_not_in: [Int!]
  rank_lt: Int
  rank_lte: Int
  rank_gt: Int
  rank_gte: Int
  vip: Int
  vip_not: Int
  vip_in: [Int!]
  vip_not_in: [Int!]
  vip_lt: Int
  vip_lte: Int
  vip_gt: Int
  vip_gte: Int
  online: Boolean
  online_not: Boolean
  verified: Int
  verified_not: Int
  verified_in: [Int!]
  verified_not_in: [Int!]
  verified_lt: Int
  verified_lte: Int
  verified_gt: Int
  verified_gte: Int
  home: Int
  home_not: Int
  home_in: [Int!]
  home_not_in: [Int!]
  home_lt: Int
  home_lte: Int
  home_gt: Int
  home_gte: Int
  volume: Int
  volume_not: Int
  volume_in: [Int!]
  volume_not_in: [Int!]
  volume_lt: Int
  volume_lte: Int
  volume_gt: Int
  volume_gte: Int
  muted: Boolean
  muted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  username: String
}
`
      }
    